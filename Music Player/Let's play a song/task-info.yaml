type: edu
files:
  - name: src/main/java/org/hyperskill/musicplayer/MainActivity.kt
    visible: true
    text: |-
      package org.hyperskill.musicplayer
      
      import android.annotation.SuppressLint
      import android.app.AlertDialog
      import android.os.Bundle
      import android.view.Menu
      import android.view.MenuItem
      import android.widget.Toast
      import androidx.activity.viewModels
      import androidx.appcompat.app.AppCompatActivity
      import androidx.lifecycle.lifecycleScope
      import androidx.recyclerview.widget.LinearLayoutManager
      import kotlinx.coroutines.launch
      import org.hyperskill.musicplayer.adapter.ItemsAdapter
      import org.hyperskill.musicplayer.databinding.ActivityMainBinding
      import org.hyperskill.musicplayer.feature.music.MainActivityUiState
      import org.hyperskill.musicplayer.feature.music.MainAddPlaylistFragment
      import org.hyperskill.musicplayer.feature.music.MainPlayerControllerFragment
      import org.hyperskill.musicplayer.feature.music.MainViewModel
      import org.hyperskill.musicplayer.model.Item
      import org.hyperskill.musicplayer.model.toTrackList
      
      
      class MainActivity : AppCompatActivity() {
      
          private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }
          private val viewModel: MainViewModel by viewModels()
      
          @SuppressLint("NotifyDataSetChanged")
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(binding.root)
              if (savedInstanceState == null) {
                  supportFragmentManager.beginTransaction()
                      .add(R.id.mainFragmentContainer, MainPlayerControllerFragment(viewModel))
                      .commit()
              }
              binding.mainButtonSearch.setOnClickListener {
                  viewModel.onSearchClick()
              }
              val itemAdapter = ItemsAdapter(
                  mutableListOf(),
                  onTrackPlayOrPause = { position -> viewModel.playOrPause(position) },
                  onTrackLongClick = { position -> viewModel.onItemLongClick(position) },
                  onSongSelectorClick = { isChecked, position ->
                      viewModel.onItemCheck(isChecked, position)
                  }
              )
              binding.mainSongList.adapter = itemAdapter
              binding.mainSongList.layoutManager = LinearLayoutManager(this)
              lifecycleScope.launch {
                  viewModel.uiState.collect {
                      when (it.state) {
                          MainActivityUiState.State.PLAY_MUSIC -> {
                              itemAdapter.update(it.currentPlayList.toTrackList(it.currentTrack))
                              supportFragmentManager.beginTransaction()
                                  .replace(
                                      R.id.mainFragmentContainer,
                                      MainPlayerControllerFragment(viewModel)
                                  )
                                  .addToBackStack(null)
                                  .commit()
                          }
      
                          MainActivityUiState.State.ADD_PLAYLIST -> {
                              itemAdapter.update(it.loadedPlaylist)
                              supportFragmentManager.beginTransaction()
                                  .replace(R.id.mainFragmentContainer, MainAddPlaylistFragment(viewModel))
                                  .addToBackStack(null)
                                  .commit()
                          }
                      }
                  }
              }
          }
      
          override fun onCreateOptionsMenu(menu: Menu?): Boolean {
              menuInflater.inflate(R.menu.menu_main, menu)
              return super.onCreateOptionsMenu(menu)
          }
      
          override fun onOptionsItemSelected(item: MenuItem): Boolean {
      
              return when (item.itemId) {
                  R.id.mainMenuAddPlaylist -> {
                      val errorString = viewModel.onMenuAddClick()
                      if (errorString.isNotEmpty()) Toast.makeText(
                          this, errorString,
                          Toast.LENGTH_SHORT
                      ).show()
                      true
                  }
      
                  R.id.mainMenuLoadPlaylist, R.id.mainMenuDeletePlaylist -> {
                      AlertDialog.Builder(this)
                          .setTitle(
                              "choose playlist to ${
                                  if (item.itemId == R.id.mainMenuLoadPlaylist)
                                      "load" else "delete"
                              }"
                          )
                          .setItems(
                              viewModel.uiState.value.playlistList.toMutableList()
                                  .apply { if (item.itemId == R.id.mainMenuDeletePlaylist && this.isNotEmpty()) removeFirst() }
                                  .map { it.name }
                                  .toTypedArray()) { _, pos ->
      
                              if (item.itemId == R.id.mainMenuLoadPlaylist) {
                                  viewModel.loadPlaylist(pos)
                              } else viewModel.deletePlaylist(pos + 1)
                          }
                          .setNegativeButton(android.R.string.cancel, null)
                          .show()
                      true
                  }
      
                  else -> super.onOptionsItemSelected(item)
              }
          }
      }
    learner_created: false
  - name: src/main/res/drawable/ic_launcher_background.xml
    visible: true
    text: |
      <?xml version="1.0" encoding="utf-8"?>
      <vector xmlns:android="http://schemas.android.com/apk/res/android"
          android:width="108dp"
          android:height="108dp"
          android:viewportWidth="108"
          android:viewportHeight="108">
          <path
              android:fillColor="#008577"
              android:pathData="M0,0h108v108h-108z" />
          <path
              android:fillColor="#00000000"
              android:pathData="M9,0L9,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,0L19,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M29,0L29,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M39,0L39,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M49,0L49,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M59,0L59,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M69,0L69,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M79,0L79,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M89,0L89,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M99,0L99,108"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,9L108,9"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,19L108,19"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,29L108,29"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,39L108,39"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,49L108,49"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,59L108,59"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,69L108,69"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,79L108,79"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,89L108,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M0,99L108,99"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,29L89,29"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,39L89,39"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,49L89,49"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,59L89,59"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,69L89,69"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M19,79L89,79"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M29,19L29,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M39,19L39,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M49,19L49,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M59,19L59,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M69,19L69,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
          <path
              android:fillColor="#00000000"
              android:pathData="M79,19L79,89"
              android:strokeWidth="0.8"
              android:strokeColor="#33FFFFFF" />
      </vector>
    learner_created: false
  - name: src/main/res/drawable/ic_pause.xml
    visible: true
    text: |
      <vector android:height="24dp" android:tint="#000000"
          android:viewportHeight="24" android:viewportWidth="24"
          android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
          <path android:fillColor="@android:color/white" android:pathData="M6,19h4L10,5L6,5v14zM14,5v14h4L18,5h-4z"/>
      </vector>
    learner_created: false
  - name: src/main/res/drawable/ic_play.xml
    visible: true
    text: |
      <vector android:height="24dp" android:tint="#000000"
          android:viewportHeight="24" android:viewportWidth="24"
          android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
          <path android:fillColor="@android:color/white" android:pathData="M8,5v14l11,-7z"/>
      </vector>
    learner_created: false
  - name: src/main/res/drawable-v24/ic_launcher_foreground.xml
    visible: true
    text: |
      <vector xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:aapt="http://schemas.android.com/aapt"
          android:width="108dp"
          android:height="108dp"
          android:viewportWidth="108"
          android:viewportHeight="108">
          <path
              android:fillType="evenOdd"
              android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
              android:strokeWidth="1"
              android:strokeColor="#00000000">
              <aapt:attr name="android:fillColor">
                  <gradient
                      android:endX="78.5885"
                      android:endY="90.9159"
                      android:startX="48.7653"
                      android:startY="61.0927"
                      android:type="linear">
                      <item
                          android:color="#44000000"
                          android:offset="0.0" />
                      <item
                          android:color="#00000000"
                          android:offset="1.0" />
                  </gradient>
              </aapt:attr>
          </path>
          <path
              android:fillColor="#FFFFFF"
              android:fillType="nonZero"
              android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
              android:strokeWidth="1"
              android:strokeColor="#00000000" />
      </vector>
    learner_created: false
  - name: src/main/res/layout/activity_main.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
      
          <Button
              android:id="@+id/mainButtonSearch"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:text="search"
              app:layout_constraintTop_toTopOf="parent" />
      
          <androidx.recyclerview.widget.RecyclerView
              android:id="@+id/mainSongList"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              app:layout_constraintTop_toBottomOf="@id/mainButtonSearch" />
      
          <androidx.fragment.app.FragmentContainerView
              android:id="@+id/mainFragmentContainer"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              app:layout_constraintBottom_toBottomOf="parent" />
      </androidx.constraintlayout.widget.ConstraintLayout>
    learner_created: false
  - name: src/main/res/mipmap-anydpi-v26/ic_launcher.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
          <background android:drawable="@drawable/ic_launcher_background" />
          <foreground android:drawable="@drawable/ic_launcher_foreground" />
      </adaptive-icon>
    learner_created: false
  - name: src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
          <background android:drawable="@drawable/ic_launcher_background" />
          <foreground android:drawable="@drawable/ic_launcher_foreground" />
      </adaptive-icon>
    learner_created: false
  - name: src/main/res/values/colors.xml
    visible: true
    text: |
      <?xml version="1.0" encoding="utf-8"?>
      <resources>
          <color name="colorPrimary">#008577</color>
          <color name="colorPrimaryDark">#00574B</color>
          <color name="colorAccent">#D81B60</color>
      </resources>
    learner_created: false
  - name: src/main/res/values/strings.xml
    visible: true
    text: |
      <resources>
          <string name="app_name">Music Player</string>
      </resources>
    learner_created: false
  - name: src/main/res/values/styles.xml
    visible: true
    text: |
      <resources>
      
          <!-- Base application theme. -->
          <style name="AppTheme" parent="Theme.MaterialComponents.Light.DarkActionBar">
              <!-- Customize your theme here. -->
              <item name="colorPrimary">@color/colorPrimary</item>
              <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
              <item name="colorAccent">@color/colorAccent</item>
          </style>
      
      </resources>
    learner_created: false
  - name: src/main/AndroidManifest.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="org.hyperskill.musicplayer">
      
        <application
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:roundIcon="@mipmap/ic_launcher_round"
            android:supportsRtl="true"
            android:theme="@style/AppTheme">
          <activity android:name="org.hyperskill.musicplayer.MainActivity">
            <intent-filter>
              <action android:name="android.intent.action.MAIN" />
      
              <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
          </activity>
        </application>
      
      </manifest>
    learner_created: false
  - name: build.gradle
    visible: true
    text: |-
      apply plugin: 'com.android.application'
      apply plugin: 'kotlin-android'
      
      android {
          compileSdkVersion hs.android.compileSdkVersion
      
          defaultConfig {
      
              applicationId "org.hyperskill.musicplayer"
              minSdkVersion hs.android.minSdkVersion
              targetSdkVersion hs.android.targetSdkVersion
              versionCode 1
              versionName '1.0'
          }
      
          buildFeatures {
              viewBinding true
          }
      }
      
      dependencies {
          def kotlinVersion = hs.android.kotlinVersion
          implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"
          implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.6.4"
      
          def coreKtx = hs.android.lib.coreKtx
          implementation "androidx.core:core-ktx:$coreKtx"
      
          def appCompat = hs.android.lib.appCompat
          implementation "androidx.appcompat:appcompat:$appCompat"
      
          def constraintLayout = hs.android.lib.constraintLayout
          implementation "androidx.constraintlayout:constraintlayout:$constraintLayout"
      
          def material = hs.android.lib.material
          implementation "com.google.android.material:material:$material"
      
          implementation "androidx.activity:activity-ktx:1.2.0"
          implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.0.0"
          implementation "androidx.recyclerview:recyclerview:1.2.0"
          implementation "androidx.fragment:fragment-ktx:1.2.0"
      }
    learner_created: false
  - name: src/main/res/layout/fragment_main_player.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:layout_margin="16dp">
      
          <TextView
              android:id="@+id/controllerTvCurrentTime"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="00:00"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
          <TextView
              android:id="@+id/controllerTvTotalTime"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="00:00"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
          <SeekBar
              android:id="@+id/controllerSeekBar"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              app:layout_constraintTop_toBottomOf="@id/controllerTvTotalTime" />
      
          <Button
              android:id="@+id/controllerBtnPlayPause"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:text="play/pause"
              app:layout_constraintEnd_toStartOf="@id/controllerBtnStop"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toBottomOf="@id/controllerSeekBar" />
      
          <Button
              android:id="@+id/controllerBtnStop"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_marginStart="16dp"
              android:text="stop"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toEndOf="@id/controllerBtnPlayPause"
              app:layout_constraintTop_toTopOf="@id/controllerBtnPlayPause" />
      
      </androidx.constraintlayout.widget.ConstraintLayout>
    learner_created: false
  - name: src/main/res/menu/menu_main.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <menu xmlns:android="http://schemas.android.com/apk/res/android">
          <item
              android:id="@+id/mainMenuAddPlaylist"
              android:title="Add Playlist" />
          <item
              android:id="@+id/mainMenuLoadPlaylist"
              android:title="Load Playlist" />
          <item
              android:id="@+id/mainMenuDeletePlaylist"
              android:title="Delete Playlist" />
      </menu>
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/model/Song.kt
    visible: true
    text: |+
      package org.hyperskill.musicplayer.model
      
      sealed class Item {
      
          data class Track(
              val song: Song,
              val state: TrackState = TrackState.STOPPED
          ) : Item() {
              enum class TrackState { PLAYING, PAUSED, STOPPED }
          }
      
          data class SongSelector(
              val song: Song,
              val isSelected: Boolean
          ) : Item()
      }
      
      data class Song(
          val id: Int,
          val title: String,
          val artist: String,
          val duration: Int
      )
      
      fun Song.toSelector(isSelected: Boolean = false): Item.SongSelector {
          return Item.SongSelector(
              song = this,
              isSelected = isSelected
          )
      }
    
    
    
    learner_created: false
  - name: src/main/res/layout/list_item_song.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/songItem"
          android:layout_width="match_parent"
          android:layout_height="wrap_content">
      
          <ImageButton
              android:id="@+id/songItemImgBtnPlayPause"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:contentDescription="YESSS"
              android:src="@drawable/ic_play"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
          <TextView
              android:id="@+id/songItemTvArtist"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="artist1"
              app:layout_constraintBottom_toTopOf="@id/songItemTvTitle"
              app:layout_constraintHorizontal_chainStyle="packed"
              app:layout_constraintStart_toEndOf="@id/songItemImgBtnPlayPause"
              app:layout_constraintTop_toTopOf="parent" />
      
          <TextView
              android:id="@+id/songItemTvTitle"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="title1"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintStart_toStartOf="@id/songItemTvArtist"
              app:layout_constraintTop_toBottomOf="@id/songItemTvArtist" />
      
          <TextView
              android:id="@+id/songItemTvDuration"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="00:00"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
      </androidx.constraintlayout.widget.ConstraintLayout>
    learner_created: false
  - name: src/main/res/layout/list_item_song_selector.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:id="@+id/songSelectorItem"
          android:layout_width="match_parent"
          android:layout_height="wrap_content">
      
          <CheckBox
              android:id="@+id/songSelectorItemCheckBox"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:src="@drawable/ic_play"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
          <TextView
              android:id="@+id/songSelectorItemTvArtist"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="artist1"
              app:layout_constraintBottom_toTopOf="@id/songSelectorItemTvTitle"
              app:layout_constraintStart_toEndOf="@id/songSelectorItemCheckBox"
              app:layout_constraintTop_toTopOf="parent"
              app:layout_constraintVertical_chainStyle="packed" />
      
          <TextView
              android:id="@+id/songSelectorItemTvTitle"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="title1"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintStart_toStartOf="@id/songSelectorItemTvArtist"
              app:layout_constraintTop_toBottomOf="@id/songSelectorItemTvArtist" />
      
          <TextView
              android:id="@+id/songSelectorItemTvDuration"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="00:00"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintTop_toTopOf="parent" />
      
      </androidx.constraintlayout.widget.ConstraintLayout>
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/model/Playlist.kt
    visible: true
    text: |
      package org.hyperskill.musicplayer.model
      
      data class Playlist(
          val name: String = "",
          val songs: List<Song> = emptyList()
      )
      
      fun Playlist.toTrackList(currentTrack: Item.Track?): List<Item.Track> {
          return this.songs.map {
              if (currentTrack != null && it.id == currentTrack.song.id) {
                  currentTrack
              } else Item.Track(it)
          }
      }
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/feature/music/MainAddPlaylistFragment.kt
    visible: true
    text: |-
      package org.hyperskill.musicplayer.feature.music
      
      import android.os.Build
      import android.os.Bundle
      import android.view.LayoutInflater
      import android.view.View
      import android.view.ViewGroup
      import android.widget.Toast
      import androidx.activity.viewModels
      import androidx.annotation.RequiresApi
      import androidx.core.widget.addTextChangedListener
      import androidx.fragment.app.Fragment
      import androidx.fragment.app.viewModels
      import androidx.lifecycle.lifecycleScope
      import kotlinx.coroutines.launch
      import org.hyperskill.musicplayer.R
      import org.hyperskill.musicplayer.databinding.ActivityMainBinding
      import org.hyperskill.musicplayer.databinding.FragmentAddPlaylistBinding
      
      class MainAddPlaylistFragment(private val viewModel: MainViewModel) : Fragment() {
      
          private var _binding: FragmentAddPlaylistBinding? = null
          private val binding get() = _binding!!
      
      
          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              _binding = FragmentAddPlaylistBinding.inflate(inflater, container, false)
              return binding.root
          }
      
          @RequiresApi(Build.VERSION_CODES.N)
          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              binding.addPlaylistBtnOk.setOnClickListener {
                  val errorString = viewModel.onAddOkClick()
                  if (errorString.isNotEmpty()) Toast.makeText(
                      this.context, errorString,
                      Toast.LENGTH_SHORT
                  ).show()
              }
              binding.addPlaylistEtPlaylistName.addTextChangedListener(onTextChanged = { text, _, _, _ ->
                  viewModel.onPlaylistNameChange(text.toString())
              })
              binding.addPlaylistBtnCancel.setOnClickListener {
                  viewModel.onCancelClick()
              }
              binding.addPlaylistEtPlaylistName.setText(viewModel.addPlaylistEtPlaylistName)
          }
      }
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/feature/music/MainPlayerControllerFragment.kt
    visible: true
    text: |-
      package org.hyperskill.musicplayer.feature.music
      
      import android.os.Bundle
      import android.view.LayoutInflater
      import android.view.View
      import android.view.ViewGroup
      import androidx.fragment.app.Fragment
      import org.hyperskill.musicplayer.R
      import org.hyperskill.musicplayer.databinding.FragmentMainPlayerBinding
      
      class MainPlayerControllerFragment(private val viewModel: MainViewModel) : Fragment() {
      
          private var _binding: FragmentMainPlayerBinding? = null
          private val binding get() = _binding!!
      
          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              _binding = FragmentMainPlayerBinding.inflate(inflater, container, false)
              return binding.root
          }
      
          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              binding.controllerBtnPlayPause.setOnClickListener {
                  viewModel.playPause()
              }
              binding.controllerBtnStop.setOnClickListener {
                  viewModel.stop()
              }
          }
      }
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/feature/music/MainViewModel.kt
    visible: true
    text: |-
      package org.hyperskill.musicplayer.feature.music
      
      import android.util.Log
      import androidx.lifecycle.ViewModel
      import kotlinx.coroutines.flow.MutableStateFlow
      import kotlinx.coroutines.flow.asStateFlow
      import kotlinx.coroutines.flow.update
      import org.hyperskill.musicplayer.feature.music.MainActivityUiState.State.ADD_PLAYLIST
      import org.hyperskill.musicplayer.feature.music.MainActivityUiState.State.PLAY_MUSIC
      import org.hyperskill.musicplayer.model.Item
      import org.hyperskill.musicplayer.model.Playlist
      import org.hyperskill.musicplayer.model.Song
      import org.hyperskill.musicplayer.model.toSelector
      
      data class MainActivityUiState(
          val currentTrack: Item.Track? = null,
          val currentPlayList: Playlist = Playlist(),
          val loadedPlaylist: List<Item.SongSelector> = emptyList(),
          val playlistList: List<Playlist> = emptyList(),
          val state: State = PLAY_MUSIC
      ) {
          enum class State { PLAY_MUSIC, ADD_PLAYLIST }
      }
      
      class MainViewModel : ViewModel() {
      
          private val _viewModelState = MutableStateFlow(MainActivityUiState())
          val uiState = _viewModelState.asStateFlow()
      
          var addPlaylistEtPlaylistName = ""
      
          private val viewModelState get() = uiState.value
          private val defaultSongs = (1..10).map {
              Song(
                  id = it,
                  artist = "artist$it",
                  title = "title$it",
                  duration = 215_000
              )
          }
          private val defaultPlaylist = Playlist("All Songs", defaultSongs)
      
          fun onSearchClick() {
              addPlaylist(defaultPlaylist)
              if (viewModelState.state == PLAY_MUSIC) {
                  _viewModelState.update {
                      it.copy(currentPlayList = defaultPlaylist)
                  }
              } else {
                  _viewModelState.update {
                      it.copy(loadedPlaylist = defaultPlaylist.songs.map { it.toSelector() })
                  }
              }
          }
      
          //region Add A Playlist
          fun onItemLongClick(position: Int) {
              onMenuAddClick()
              _viewModelState.update {
                  it.copy(
                      loadedPlaylist = it.loadedPlaylist.toMutableList().apply {
                          this[position] = this[position].copy(isSelected = true)
                      }
                  )
              }
          }
      
          fun onMenuAddClick(): String {
              if (viewModelState.currentPlayList.songs.isEmpty()) {
                  return "no songs loaded, click search to load songs"
              }
              _viewModelState.update {
                  it.copy(
                      state = ADD_PLAYLIST,
                      loadedPlaylist = defaultSongs.map { song -> song.toSelector() })
              }
              return ""
          }
      
          fun onItemCheck(isChecked: Boolean, position: Int) {
              _viewModelState.update {
                  it.copy(
                      loadedPlaylist = it.loadedPlaylist.toMutableList().apply {
                          this[position] = this[position].copy(isSelected = isChecked)
                      }
                  )
              }
          }
      
          fun onPlaylistNameChange(name: String) {
              addPlaylistEtPlaylistName = name
          }
      
          fun onAddOkClick(): String {
              if (viewModelState.loadedPlaylist.none { it.isSelected }) return "Add at least one song to your playlist"
              if (addPlaylistEtPlaylistName.isBlank()) return "Add a name to your playlist"
              if (addPlaylistEtPlaylistName == "All Songs") return "All Songs is a reserved name choose another playlist name"
              addPlaylist(
                  Playlist(
                      addPlaylistEtPlaylistName,
                      viewModelState.loadedPlaylist.filter { it.isSelected }
                          .map { selector -> selector.song }
                  ))
              _viewModelState.update { it.copy(state = PLAY_MUSIC) }
              return ""
          }
      
          fun onCancelClick() {
              _viewModelState.update {
                  it.copy(
                      state = PLAY_MUSIC,
                      loadedPlaylist = emptyList()
                  )
              }
          }
      
          private fun addPlaylist(playlist: Playlist) {
              if (viewModelState.playlistList.none { it.name == playlist.name }) {
                  _viewModelState.update {
                      it.copy(playlistList = it.playlistList + playlist)
                  }
              }
          }
          //endregion
      
          fun loadPlaylist(position: Int) {
              val newPlaylist = viewModelState.playlistList[position]
              if (viewModelState.state == PLAY_MUSIC) {
                  val shouldKeepCurrentTrack =
                      viewModelState.currentTrack?.song in viewModelState.playlistList[position].songs
                  _viewModelState.update {
                      it.copy(
                          currentTrack = if (shouldKeepCurrentTrack) it.currentTrack else null,
                          currentPlayList = newPlaylist
                      )
                  }
              } else {
                  _viewModelState.update {
      
                      val includedInOldListAndSelectedIds = viewModelState.loadedPlaylist
                          .filter { selector -> selector.song in newPlaylist.songs && selector.isSelected }
                          .map { selector -> selector.song.id }
                      it.copy(
                          loadedPlaylist = it.playlistList[position].songs.map { song ->
                              song.toSelector(
                                  song.id in includedInOldListAndSelectedIds
                              )
                          }
                      )
                  }
              }
          }
      
          fun deletePlaylist(position: Int) {
              val thisPlaylist = viewModelState.playlistList[position]
              _viewModelState.update {
                  it.copy(
                      playlistList = it.playlistList.toMutableList().apply { remove(thisPlaylist) },
                      currentPlayList = if (it.currentPlayList == thisPlaylist) defaultPlaylist else it.currentPlayList,
                      loadedPlaylist = if (it.loadedPlaylist.map { selector -> selector.song } ==
                          thisPlaylist.songs && it.state == ADD_PLAYLIST) {
                          defaultPlaylist.songs.map { song -> song.toSelector() }
                      } else it.loadedPlaylist
                  )
              }
          }
      
          fun playOrPause(position: Int) {
              if (viewModelState.currentTrack != null &&
                  viewModelState.currentPlayList.songs[position].id == viewModelState.currentTrack!!.song.id
              ) {
                  switchCurrentTrackState()
                  return
              }
      
              _viewModelState.update {
                  it.copy(
                      currentTrack = Item.Track(
                          song = viewModelState.currentPlayList.songs[position],
                          state = Item.Track.TrackState.PLAYING
                      )
                  )
              }
          }
      
          fun playPause() {
              if (viewModelState.currentPlayList.songs.isEmpty()) return
              if (viewModelState.currentTrack != null) {
                  switchCurrentTrackState()
                  return
              }
              _viewModelState.update {
                  it.copy(
                      currentTrack = Item.Track(
                          song = viewModelState.currentPlayList.songs[0],
                          state = Item.Track.TrackState.PLAYING
                      )
                  )
              }
          }
      
          fun stop() {
              _viewModelState.update { it.copy(currentTrack = null) }
          }
      
          private fun switchCurrentTrackState() {
              _viewModelState.update {
                  it.copy(
                      currentTrack = it.currentTrack?.copy(
                          state = if (it.currentTrack.state == Item.Track.TrackState.PLAYING) {
                              Item.Track.TrackState.PAUSED
                          } else Item.Track.TrackState.PLAYING
                      )
                  )
              }
          }
      }
    learner_created: false
  - name: src/main/res/layout/fragment_add_playlist.xml
    visible: true
    text: |-
      <?xml version="1.0" encoding="utf-8"?>
      <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="wrap_content">
      
          <EditText
              android:id="@+id/addPlaylistEtPlaylistName"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="Playlist Name"
              app:layout_constraintTop_toTopOf="parent" />
      
          <Button
              android:id="@+id/addPlaylistBtnCancel"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:text="@android:string/cancel"
              app:layout_constraintEnd_toStartOf="@id/addPlaylistBtnOk"
              app:layout_constraintStart_toStartOf="parent"
              app:layout_constraintTop_toBottomOf="@id/addPlaylistEtPlaylistName" />
      
          <Button
              android:id="@+id/addPlaylistBtnOk"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_marginStart="16dp"
              android:text="@android:string/ok"
              app:layout_constraintEnd_toEndOf="parent"
              app:layout_constraintStart_toEndOf="@id/addPlaylistBtnCancel"
              app:layout_constraintTop_toTopOf="@id/addPlaylistBtnCancel" />
      
      </androidx.constraintlayout.widget.ConstraintLayout>
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/helper/DurationHelper.kt
    visible: true
    text: |-
      package org.hyperskill.musicplayer.helper
      
      import kotlin.time.DurationUnit
      import kotlin.time.toDuration
      
      fun formatMilliseconds(milliseconds: Int): String {
          val duration = milliseconds.toDuration(DurationUnit.MILLISECONDS)
          val minutes = duration.inWholeMinutes
          val seconds = duration.minus(minutes.toDuration(DurationUnit.MINUTES)).inWholeSeconds
          return "${"%02d".format(minutes)}:$seconds"
      }
    learner_created: false
  - name: src/main/java/org/hyperskill/musicplayer/adapter/ItemsAdapter.kt
    visible: true
    text: |
      package org.hyperskill.musicplayer.adapter
      
      import android.graphics.Color
      import android.view.LayoutInflater
      import android.view.View
      import android.view.ViewGroup
      import android.widget.CheckBox
      import android.widget.ImageView
      import android.widget.TextView
      import androidx.constraintlayout.widget.ConstraintLayout
      import androidx.recyclerview.widget.DiffUtil
      import androidx.recyclerview.widget.RecyclerView
      import org.hyperskill.musicplayer.R
      import org.hyperskill.musicplayer.helper.formatMilliseconds
      import org.hyperskill.musicplayer.model.Item
      
      
      class ItemsAdapter(
          private val items: MutableList<Item>,
          private val onTrackPlayOrPause: (Int) -> Unit,
          private val onTrackLongClick: (Int) -> Unit,
          private val onSongSelectorClick: (Boolean, Int) -> Unit
      ) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
      
          fun update(newItems: List<Item>) {
              val diffCallback = ItemsDiffCallback(items, newItems)
              val diffResult = DiffUtil.calculateDiff(diffCallback)
              this.items.clear()
              this.items.addAll(newItems)
              diffResult.dispatchUpdatesTo(this)
          }
      
          override fun getItemCount(): Int {
              return items.size
          }
      
          override fun getItemViewType(position: Int): Int {
              return when (items[position]) {
                  is Item.Track -> 0
                  is Item.SongSelector -> 1
              }
          }
      
          override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
              return when (viewType) {
                  0 -> {
                      TrackViewHolder(
                          LayoutInflater.from(parent.context)
                              .inflate(R.layout.list_item_song, parent, false)
                      ).apply {
                          songItem.setOnLongClickListener { _ ->
                              val pos = bindingAdapterPosition
                              if (pos >= 0) {
                                  onTrackLongClick(pos)
                                  true
                              } else false
                          }
                          songItemImgBtnPlayPause.setOnClickListener {
                              val pos = bindingAdapterPosition
                              if (pos >= 0) {
                                  onTrackPlayOrPause(pos)
                              }
                          }
                      }
                  }
      
                  1 -> {
                      SongSelectorViewHolder(
                          LayoutInflater.from(parent.context)
                              .inflate(R.layout.list_item_song_selector, parent, false)
                      ).apply {
                          songSelectorItem.setOnClickListener {
                              songSelectorItemCheckBox.apply { isChecked = !isChecked }
                          }
                          songSelectorItemCheckBox.setOnCheckedChangeListener { _, isChecked ->
                              val pos = bindingAdapterPosition
                              if (pos >= 0) {
                                  onSongSelectorClick(isChecked, pos)
                              }
                          }
                      }
                  }
      
                  else -> throw AssertionError()
              }
          }
      
      
          override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
              when (val item = items[position]) {
                  is Item.Track -> {
                      (holder as TrackViewHolder).apply {
                          songItemTvArtist.text = item.song.artist
                          songItemTvTitle.text = item.song.title
                          songItemTvDuration.text = formatMilliseconds(item.song.duration)
                          songItemImgBtnPlayPause.setImageResource(
                              when (item.state) {
                                  Item.Track.TrackState.PLAYING -> R.drawable.ic_pause
                                  else -> R.drawable.ic_play
                              }
                          )
                      }
                  }
      
                  is Item.SongSelector -> {
                      (holder as SongSelectorViewHolder).apply {
                          songSelectorItemTvArtist.text = item.song.artist
                          songSelectorItemTvTitle.text = item.song.title
                          songSelectorItemTvDuration.text = formatMilliseconds(item.song.duration)
                          songSelectorItemCheckBox.isChecked = item.isSelected
                          if (songSelectorItemCheckBox.isChecked) {
                              holder.songSelectorItem.setBackgroundColor(Color.LTGRAY)
                          } else {
                              holder.songSelectorItem.setBackgroundColor(Color.WHITE)
                          }
                      }
                  }
              }
          }
      
          class TrackViewHolder(view: View) : RecyclerView.ViewHolder(view) {
              val songItem: ConstraintLayout = view.findViewById(R.id.songItem)
              val songItemImgBtnPlayPause: ImageView = view.findViewById(R.id.songItemImgBtnPlayPause)
              val songItemTvArtist: TextView = view.findViewById(R.id.songItemTvArtist)
              val songItemTvTitle: TextView = view.findViewById(R.id.songItemTvTitle)
              val songItemTvDuration: TextView = view.findViewById(R.id.songItemTvDuration)
          }
      
          class SongSelectorViewHolder(view: View) : RecyclerView.ViewHolder(view) {
              val songSelectorItem: ConstraintLayout = view.findViewById(R.id.songSelectorItem)
              val songSelectorItemCheckBox: CheckBox = view.findViewById(R.id.songSelectorItemCheckBox)
              val songSelectorItemTvArtist: TextView = view.findViewById(R.id.songSelectorItemTvArtist)
              val songSelectorItemTvTitle: TextView = view.findViewById(R.id.songSelectorItemTvTitle)
              val songSelectorItemTvDuration: TextView =
                  view.findViewById(R.id.songSelectorItemTvDuration)
          }
      }
      
      class ItemsDiffCallback(
          private val oldItems: List<Item>,
          private val newItems: List<Item>
      ) : DiffUtil.Callback() {
      
          override fun getOldListSize(): Int = oldItems.size
      
          override fun getNewListSize(): Int = newItems.size
      
          override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
              val oldItem = oldItems[oldItemPosition]
              val newItem = newItems[newItemPosition]
              return oldItem::class == newItem::class && when (oldItem) {
                  is Item.Track -> {
                      newItem as Item.Track
                      oldItem.song.id == newItem.song.id
                  }
      
                  is Item.SongSelector -> {
                      newItem as Item.SongSelector
                      oldItem.song.id == newItem.song.id
                  }
              }
          }
      
          override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
              val oldItem = oldItems[oldItemPosition]
              val newItem = newItems[newItemPosition]
              return oldItem == newItem
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/AbstractUnitTest.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals
      
      import android.app.Activity
      import android.content.Intent
      import android.os.Bundle
      import android.os.SystemClock
      import android.view.View
      import android.widget.SeekBar
      import org.junit.Assert
      import org.junit.Assert.assertNotNull
      import org.junit.Assert.assertTrue
      import org.robolectric.Robolectric
      import org.robolectric.Shadows.shadowOf
      import org.robolectric.android.controller.ActivityController
      import org.robolectric.shadow.api.Shadow
      import org.robolectric.shadows.ShadowActivity
      import org.robolectric.shadows.ShadowLooper
      import org.robolectric.shadows.ShadowToast
      import java.time.Duration
      
      // version 1.3
      abstract class AbstractUnitTest<T : Activity>(clazz: Class<T>) {
      
          /**
           * Setup and control activities and their lifecycle
           */
          val activityController: ActivityController<T> by lazy {
              Robolectric.buildActivity(clazz)
          }
      
          /**
           * The activity being tested.
           *
           * It is the @RealObject of the shadowActivity
           */
          val activity : Activity by lazy {
              activityController.get()
          }
      
          /**
           * A Roboletric shadow object of the Activity class, contains helper methods to deal with
           * testing activities like setting permissions, peeking results of launched activities for result,
           * retrieving shown dialogs, intents and others.
           *
           * If you don't know what shadows are you can have a better understanding on that reading this
           * on roboletric documentation: http://robolectric.org/extending/
           *
           * Understanding Shadows is fundamental for Roboletric, things are not what they appear to be on
           * Roboletric because running a code on the jvm is not the same as running the code on a real/emulated device.
           * Code that expects to eventually talk to the machine won't have the machine they expect to have to talk to.
           * Shadow is how Roboletric makes things possible, they impersonate @RealObject and act when @RealObject is expected to act.
           *
           * Things in Roboletric are not what they appear to be.
           * It is possible to not notice it for the most part, but it will be essential for some other parts
           */
          val shadowActivity: ShadowActivity by lazy {
              Shadow.extract(activity)
          }
      
          /**
           * A Roboletric shadow object of the mainLooper. Handles enqueued runnables and also the passage of time.
           *
           * Usually used with .idleFor(someDurationValue) or .runToEndOfTasks()
           */
          val shadowLooper: ShadowLooper by lazy {
              shadowOf(activity.mainLooper)
          }
      
          /**
           * Decorate your test code with this method to ensure better error messages displayed
           * when tests are run with check button and exceptions are thrown by user implementation.
           *
           * returns a value for convenience use, like in tests that involve navigation between Activities
           */
          fun <ReturnValue> testActivity(arguments: Intent = Intent(), savedInstanceState: Bundle = Bundle(), testCodeBlock: (Activity) -> ReturnValue): ReturnValue {
              try {
                  activity.intent =  arguments
                  activityController.setup(savedInstanceState)
              } catch (ex: Exception) {
                  throw AssertionError("Exception, test failed on activity creation with $ex\n${ex.stackTraceToString()}")
              }
      
              return try {
                  testCodeBlock(activity)
              } catch (ex: Exception) {
                  throw AssertionError("Exception. Test failed on activity execution with $ex\n${ex.stackTraceToString()}")
              }
          }
      
          /**
           * Use this method to find views.
           *
           * The view existence will be assert before being returned
           */
          inline fun <reified T> Activity.findViewByString(idString: String): T {
              val id = this.resources.getIdentifier(idString, "id", this.packageName)
              val view: View? = this.findViewById(id)
      
              val idNotFoundMessage = "View with id \"$idString\" was not found"
              val wrongClassMessage = "View with id \"$idString\" is not from expected class. " +
                      "Expected ${T::class.java.simpleName} found ${view?.javaClass?.simpleName}"
      
              assertNotNull(idNotFoundMessage, view)
              assertTrue(wrongClassMessage, view is T)
      
              return view as T
          }
      
          /**
           * Use this method to find views.
           *
           * The view existence will be assert before being returned
           */
          inline fun <reified T> View.findViewByString(idString: String): T {
              val id = this.resources.getIdentifier(idString, "id", context.packageName)
              val view: View? = this.findViewById(id)
      
              val idNotFoundMessage = "View with id \"$idString\" was not found"
              val wrongClassMessage = "View with id \"$idString\" is not from expected class. " +
                      "Expected ${T::class.java.simpleName} found ${view?.javaClass?.simpleName}"
      
              assertNotNull(idNotFoundMessage, view)
              assertTrue(wrongClassMessage, view is T)
      
              return view as T
          }
      
          /**
           * Use this method to perform clicks. It will also advance the clock millis milliseconds and run
           * enqueued Runnable scheduled to run on main looper in that timeframe.
           * Default value for millis is 500.
           *
           * Internally it calls performClick(), which might or might not increase clock time by itself
           * depending on the actions performed during click. If possible the amount of millis will
           * be corrected on the call to shadowLooper.idleFor(millis), but it is not possible to idleFor
           * negative values, which means it is not always possible to increase 0 millis.
           *
           * Returns the actual amount increased to help keep track of time elapsed.
           *
           */
          fun View.clickAndRun(millis: Long = 500): Int {
              val timeBeforeClick = SystemClock.currentGnssTimeClock().millis()
              this.performClick()
              val timeAfterClick = SystemClock.currentGnssTimeClock().millis()
              shadowLooper.idleFor(Duration.ofMillis(millis - (timeAfterClick - timeBeforeClick)))
              val timeAfterIdle = SystemClock.currentGnssTimeClock().millis()
              return (timeAfterIdle - timeBeforeClick).toInt()
          }
      
          /**
           * Use this method to perform long clicks. It will also advance the clock millis milliseconds and run
           * enqueued Runnable scheduled to run on main looper in that timeframe.
           * Default value for millis is 500
           *
           * Internally it calls performLongClick(), which might or might not increase clock time by itself
           * depending on the actions performed during click. If possible the amount of millis will
           * be corrected on the call to shadowLooper.idleFor(millis), but it is not possible to idleFor
           * negative values, which means it is not always possible to increase 0 millis.
           *
           * Returns the actual amount increased to help keep track of time elapsed.
           */
          fun View.clickLongAndRun(millis: Long = 500): Int {
              val timeBeforeClick = SystemClock.currentGnssTimeClock().millis()
              this.performLongClick()
              val timeAfterClick = SystemClock.currentGnssTimeClock().millis()
              shadowLooper.idleFor(Duration.ofMillis(millis - (timeAfterClick - timeBeforeClick)))
              val timeAfterIdle = SystemClock.currentGnssTimeClock().millis()
              return (timeAfterIdle - timeBeforeClick).toInt()
          }
      
          /**
           * Asserts that the last message toasted is the expectedMessage.
           * Assertion fails if no toast is shown with null actualLastMessage value.
           */
          fun assertLastToastMessageEquals(errorMessage: String, expectedMessage: String,) {
              val actualLastMessage: String? = ShadowToast.getTextOfLatestToast()
              Assert.assertEquals(errorMessage, expectedMessage, actualLastMessage)
          }
      
          /**
           * Use this method to set the progress as a user.
           *
           * Will trigger attached listeners.
           *
           * First onStartTrackingTouch(), then onProgressChanged() as user, and finally onStopTrackingTouch()
           */
          fun SeekBar.setProgressAsUser(progress: Int) {
              val shadowSeekBar = shadowOf(this)
              assertNotNull("Expected seekbar to have a onSeekBarChangeListener", shadowSeekBar.onSeekBarChangeListener)
      
              shadowSeekBar.onSeekBarChangeListener.onStartTrackingTouch(this)
      
              // using java reflection to change progress without triggering listener
              var clazz: Class<*> = this::class.java  // may be subclass of SeekBar
              while(clazz.name != "android.widget.ProgressBar") {  // since SeekBar is a subclass of ProgressBar this should not be an infinite loop
                  clazz = clazz.superclass as Class<*>
              }
              val progressBarClazz = clazz
              val progressField = progressBarClazz.getDeclaredField("mProgress")
              progressField.isAccessible = true
              progressField.setInt(this, progress)
              //
      
              shadowSeekBar.onSeekBarChangeListener.onProgressChanged(this, progress, true)
              shadowSeekBar.onSeekBarChangeListener.onStopTrackingTouch(this)
          }
      
          /**
           * Use this method to make assertions on requisition of permissions
           *
           * @param permissionsRequired list of requiredPermission, ex: listOf(Manifest.permission.READ_EXTERNAL_STORAGE)
           * @param expectedRequestCode requestCode that test expect implementation to use in their code
           */
          fun assertRequestPermissions(permissionsRequired: List<String>, expectedRequestCode: Int = 1){
      
              val messageAnyPermissionRequest = "Have you asked any permissions?"
              val permissionRequest = shadowActivity.lastRequestedPermission ?: throw java.lang.AssertionError(
                  messageAnyPermissionRequest
              )
      
              permissionsRequired.forEach { permissionRequired: String ->
      
                  val messagePermissionRequired = "Have you asked permission $permissionRequired"
      
                  val hasRequestedPermission =
                      permissionRequest.requestedPermissions.any { it == permissionRequired }
                  assert(hasRequestedPermission) { messagePermissionRequired }
      
                  val actualRequestCode = permissionRequest.requestCode
                  val messageWrongRequestCode =
                      "Did you use the requestCode stated on description while requiring permissions?"
                  Assert.assertEquals(messageWrongRequestCode, expectedRequestCode, actualRequestCode)
              }
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/CustomMediaPlayerShadow.java
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals;
      
      import static org.junit.Assert.assertEquals;
      import static org.robolectric.shadows.ShadowMediaPlayer.State.INITIALIZED;
      
      import android.content.ContentUris;
      import android.content.Context;
      import android.content.res.AssetFileDescriptor;
      import android.media.AudioAttributes;
      import android.media.MediaDataSource;
      import android.media.MediaPlayer;
      import android.net.Uri;
      import android.provider.MediaStore;
      import android.view.SurfaceHolder;
      
      import org.hyperskill.musicplayer.R;
      import org.robolectric.annotation.Implementation;
      import org.robolectric.annotation.Implements;
      import org.robolectric.shadow.api.Shadow;
      import org.robolectric.shadows.ShadowMediaPlayer;
      import org.robolectric.shadows.util.DataSource;
      
      import java.io.FileDescriptor;
      import java.io.IOException;
      import java.net.HttpCookie;
      import java.util.List;
      import java.util.Map;
      // version 1.3
      @Implements(MediaPlayer.class)
      public class CustomMediaPlayerShadow extends ShadowMediaPlayer {
      
          private static SongFake fakeSong = new SongFake(
                  -1,
                  "Guggenheim grotto",
                  "Wisdom",
                  215_000
          );
      
          public static boolean wasResetOrRecreated = false;
      
      
          @Implementation
          public static MediaPlayer create(Context context, int resid){
              if(resid == R.raw.wisdom) {
                  DataSource dataSource = DataSource.toDataSource(String.valueOf(resid));
                  MediaInfo info = new MediaInfo(fakeSong.getDuration(), 0);
      
                  addMediaInfo(dataSource, info);
      
                  MediaPlayer mediaPlayer = new MediaPlayer();
                  ShadowMediaPlayer shadow = Shadow.extract(mediaPlayer);
                  try {
                      shadow.setDataSource(dataSource);
                      shadow.setState(INITIALIZED);
                      mediaPlayer.prepare();
                  } catch (Exception e) {
                      return null;
                  }
                  wasResetOrRecreated = true;
                  return mediaPlayer;
              }
              throw new AssertionError("invalid resid provided to MediaPlayer.create(Context context, int resid)");
          }
      
          @Implementation
          protected static MediaPlayer create(
                  Context context, int resid, AudioAttributes audioAttributes, int audioSessionId) {
      
              return create(context, resid);
          }
      
          @Implementation
          protected static MediaPlayer create(Context context, Uri trackUri){
              if(trackUri.getPath().equals("/raw/wisdom")) {
                  return create(context, R.raw.wisdom);
              }
      
              Uri expectedSongUri = ContentUris.withAppendedId(
                      MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                      fakeSong.getId()
              );
      
              assertEquals("Media player created with incorrect uri", expectedSongUri.getPath(), trackUri.getPath());
      
              DataSource dataSource = DataSource.toDataSource(context, trackUri);
      
              MediaInfo info = new MediaInfo((int) fakeSong.getDuration(), 0);
              addMediaInfo(dataSource, info);
      
              MediaPlayer mediaPlayer = new MediaPlayer();
              ShadowMediaPlayer shadow = Shadow.extract(mediaPlayer);
              try {
                  shadow.setDataSource(dataSource);
                  shadow.setState(INITIALIZED);
                  mediaPlayer.prepare();
              } catch (Exception e) {
                  return null;
              }
              wasResetOrRecreated = true;
              return mediaPlayer;
          }
      
          @Implementation
          protected static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder) {
              return create(context, uri);
          }
      
          @Implementation
          protected static MediaPlayer create(Context context, Uri uri, SurfaceHolder holder,
                                              AudioAttributes audioAttributes, int audioSessionId) {
              return create(context, uri);
          }
      
          @Implementation
          @Override
          protected void setDataSource(
                  Context context,
                  Uri trackUri,
                  Map<String, String> headers,
                  List<HttpCookie> cookies) throws IOException {
      
              if(trackUri.getPath().equals("/raw/wisdom")) {
                  DataSource dataSource = DataSource.toDataSource(context, trackUri);
                  MediaInfo info = new MediaInfo(fakeSong.getDuration(), 0);
                  addMediaInfo(dataSource, info);
              } else {
                  Uri expectedSongUri = ContentUris.withAppendedId(
                          MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                          fakeSong.getId()
                  );
      
                  assertEquals(
                          "Media player created with incorrect uri",
                          expectedSongUri.getPath(), trackUri.getPath()
                  );
      
                  DataSource dataSource = DataSource.toDataSource(context, trackUri);
                  MediaInfo info = new MediaInfo((int) fakeSong.getDuration(), 0);
                  addMediaInfo(dataSource, info);
              }
      
              super.setDataSource(context, trackUri, headers, cookies);
          }
      
          @Implementation
          @Override
          protected void setDataSource(Context context, Uri trackUri) throws IOException {
              setDataSource(context, trackUri, null, null);
          }
      
          @Implementation
          @Override
          protected void setDataSource(
                  Context context, Uri uri, Map<String, String> headers) throws IOException {
              setDataSource(context, uri, null, null);
          }
      
          @Implementation
          @Override
          protected void setDataSource(String uri, Map<String, String> headers) throws IOException {
              throw new AssertionError(
                      "tests do not support the method " +
                              ".setDataSource(String uri, Map<String, String> headers), " +
                              "use .setDataSource(Context context, Uri uri) instead"
              );
          }
      
          @Implementation
          @Override
          protected void setDataSource(FileDescriptor fd, long offset, long length) throws IOException {
              throw new AssertionError(
                      "tests do not support the method " +
                              ".setDataSource(FileDescriptor fd, long offset, long length), " +
                              "use .setDataSource(Context context, Uri uri) instead"
              );
          }
      
          @Implementation
          @Override
          protected void setDataSource(MediaDataSource mediaDataSource) throws IOException {
              throw new AssertionError(
                      "tests do not support the method " +
                              ".setDataSource(MediaDataSource mediaDataSource), " +
                              "use .setDataSource(Context context, Uri uri) instead"
              );
          }
      
          @Implementation
          @Override
          protected void setDataSource(AssetFileDescriptor assetFileDescriptor) throws IOException {
              throw new AssertionError(
                      "tests do not support the method " +
                              ".setDataSource(AssetFileDescriptor assetFileDescriptor), " +
                              "use .setDataSource(Context context, Uri uri) instead"
              );
          }
      
          @Implementation
          @Override
          protected void _reset() {
              wasResetOrRecreated = true;
              super._reset();
          }
      
          public static void setFakeSong(SongFake fakeSong) {
              CustomMediaPlayerShadow.fakeSong = fakeSong;
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/CustomShadowAsyncDifferConfig.java
    visible: false
    text: |
      package org.hyperskill.musicplayer.internals;
      
      import android.os.Handler;
      import android.os.Looper;
      
      import androidx.recyclerview.widget.AsyncDifferConfig;
      
      import org.robolectric.annotation.Implementation;
      import org.robolectric.annotation.Implements;
      
      import java.util.concurrent.Executor;
      
      @Implements(AsyncDifferConfig.class)
      @SuppressWarnings({"unused"})
      public class CustomShadowAsyncDifferConfig {
      
          public static class MainThreadExecutor implements Executor {
              private final Handler handler = new Handler(Looper.getMainLooper());
      
              @Override
              public void execute(Runnable r) {
                  handler.post(r);
              }
          }
          Executor mainExecutor;
      
          @Implementation
          public Executor getBackgroundThreadExecutor() {
              if(mainExecutor == null) {
                  mainExecutor = new MainThreadExecutor();
              }
              return mainExecutor;
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/CustomShadowCountDownTimer.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals
      
      import android.os.CountDownTimer
      import android.os.Handler
      import org.robolectric.annotation.Implementation
      import org.robolectric.annotation.Implements
      import org.robolectric.annotation.RealObject
      import org.robolectric.shadow.api.Shadow
      import org.robolectric.util.ReflectionHelpers
      // version 1.3
      // adapted from ShadowCountDownTimer
      // https://github.com/robolectric/robolectric/blob/master/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCountDownTimer.java
      @Implements(CountDownTimer::class)
      class CustomShadowCountDownTimer {
      
          companion object {
              var handler: Handler? = null
          }
      
          private var started = false
          var countDownInterval: Long = 0
              private set
          var millisInFuture: Long = 0
              private set
      
          var millisUntilFinished: Long = 0
      
          val runnable: Runnable = Runnable {
              invokeTick(millisUntilFinished)
          }
      
          @RealObject
          var countDownTimer: CountDownTimer? = null
      
          @Implementation
          protected fun __constructor__(millisInFuture: Long, countDownInterval: Long) {
              this.countDownInterval = countDownInterval
              this.millisInFuture = millisInFuture
              this.millisUntilFinished = millisInFuture
              started = false
              Shadow.invokeConstructor(
                  CountDownTimer::class.java,
                  countDownTimer,
                  ReflectionHelpers.ClassParameter.from(Long::class.javaPrimitiveType, millisInFuture),
                  ReflectionHelpers.ClassParameter.from(Long::class.javaPrimitiveType, countDownInterval))
          }
      
          @Implementation
          @Synchronized
          protected fun start(): CountDownTimer? {
              started = true
              handler?.post(runnable)
              return countDownTimer
          }
      
          @Implementation
          protected fun cancel() {
              started = false
              handler?.removeCallbacks(runnable)
          }
      
          fun invokeTick(millisUntilFinished: Long) {
              countDownTimer!!.onTick(millisUntilFinished)
              this.millisUntilFinished = this.millisUntilFinished - countDownInterval
              if(this.millisUntilFinished >= 0) {
                  handler?.postDelayed(runnable, countDownInterval)
              } else {
                  invokeFinish()
              }
          }
      
          fun invokeFinish() {
              countDownTimer!!.onFinish()
          }
      
          fun hasStarted(): Boolean {
              return started
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/FakeContentProvider.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals
      
      import android.content.ContentProvider
      import android.content.ContentValues
      import android.database.Cursor
      import android.database.MatrixCursor
      import android.net.Uri
      import android.provider.MediaStore
      // version 1.3
      class FakeContentProvider : ContentProvider() {
      
          companion object {
              var fakeSongResult: List<SongFake> = listOf()
              var hasPermissionToReadExternalStorage = true
          }
      
          override fun onCreate(): Boolean {
              return true
          }
      
          override fun query(
              uri: Uri,
              projection: Array<out String>?,
              selection: String?,
              selectionArgs: Array<out String>?,
              sortOrder: String?
          ): Cursor? {
      
              if(hasPermissionToReadExternalStorage.not()) {
                  throw AssertionError(
                      "You are trying to read from external storage, " +
                              "but you don't have permission to read from external storage"
                  )
              }
      
              val columns = listOf (
                  MediaStore.Audio.Media._ID,
                  MediaStore.Audio.Media.ARTIST,
                  MediaStore.Audio.Media.TITLE,
                  MediaStore.Audio.Media.DURATION,
              )
      
              return if (uri == MediaStore.Audio.Media.EXTERNAL_CONTENT_URI) {
                  val cursor = MatrixCursor(
                      columns.filter { projection?.contains(it) ?: true }
                          .sortedBy { projection?.indexOf(it) ?: columns.indexOf(it)}
                          .toTypedArray()
                  )
                  addMockRows(cursor, projection)
                  cursor
              } else {
                  null
              }
          }
      
          private fun addMockRows(cursor: MatrixCursor, projection: Array<out String>?) {
              for (song in fakeSongResult) {
                  val rowBuilder = cursor.newRow()
                  if (projection?.contains(MediaStore.Audio.Media._ID) != false) {  // if (true || null) then add
                      rowBuilder.add(MediaStore.Audio.Media._ID, song.id)
                  }
                  if (projection?.contains(MediaStore.Audio.Media.ARTIST) != false) {
                      rowBuilder.add(MediaStore.Audio.Media.ARTIST, song.artist)
                  }
                  if (projection?.contains(MediaStore.Audio.Media.TITLE) != false) {
                      rowBuilder.add(MediaStore.Audio.Media.TITLE, song.title)
                  }
                  if (projection?.contains(MediaStore.Audio.Media.DURATION) != false) {
                      rowBuilder.add(MediaStore.Audio.Media.DURATION, song.duration)
                  }
              }
          }
      
          override fun getType(uri: Uri): String? {
              throw NotImplementedError()
          }
      
          override fun insert(uri: Uri, values: ContentValues?): Uri? {
              throw NotImplementedError()
          }
      
          override fun delete(uri: Uri, selection: String?, selectionArgs: Array<out String>?): Int {
              throw NotImplementedError()
          }
      
          override fun update(
              uri: Uri,
              values: ContentValues?,
              selection: String?,
              selectionArgs: Array<out String>?
          ): Int {
              throw NotImplementedError()
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/MusicPlayerUnitTests.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals
      
      
      import android.app.Activity
      import android.app.AlertDialog
      import android.content.pm.ProviderInfo
      import android.graphics.Color
      import android.graphics.drawable.ColorDrawable
      import android.graphics.drawable.Drawable
      import android.media.MediaPlayer
      import android.os.SystemClock
      import android.provider.MediaStore
      import android.view.View
      import android.widget.*
      import androidx.annotation.ColorInt
      import androidx.fragment.app.FragmentContainerView
      import androidx.recyclerview.widget.RecyclerView
      import org.junit.Assert.*
      import org.robolectric.Robolectric
      import org.robolectric.Shadows
      import org.robolectric.shadow.api.Shadow
      import org.robolectric.shadows.ShadowAlertDialog
      import org.robolectric.shadows.ShadowMediaPlayer
      import java.time.Duration
      import java.util.Collections.max
      import java.util.concurrent.TimeUnit
      import kotlin.math.abs
      
      // version 1.3
      open class MusicPlayerUnitTests<T : Activity>(clazz: Class<T>): AbstractUnitTest<T>(clazz) {
      
      
          init {
              CustomMediaPlayerShadow.setCreateListener(::onMediaPlayerCreated)
          }
      
          private var playerPrivate: MediaPlayer? = null
          private var shadowPlayerPrivate: ShadowMediaPlayer? = null
      
          protected var player: MediaPlayer
              get() {
                  assertNotNull("No MediaPlayer was found", playerPrivate)
                  return this.playerPrivate!!
              }
              set(_) {}
      
          protected var shadowPlayer: ShadowMediaPlayer
              get() {
                  assertNotNull("No MediaPlayer was found", playerPrivate)
                  shadowPlayer.invalidStateBehavior = ShadowMediaPlayer.InvalidStateBehavior.ASSERT
                  return this.shadowPlayerPrivate!!
              }
              set(_) {}
      
          fun isPlayerNull(): Boolean {
              return playerPrivate == null
          }
      
          private fun onMediaPlayerCreated(player: MediaPlayer, shadow: ShadowMediaPlayer) {
              playerPrivate = player
              shadowPlayerPrivate = shadow
          }
      
          fun setupContentProvider(fakeSongResult: List<SongFake>){
              val info = ProviderInfo().apply {
                  authority = MediaStore.AUTHORITY
              }
              Robolectric.buildContentProvider(FakeContentProvider::class.java).create(info)
              FakeContentProvider.fakeSongResult = fakeSongResult
          }
      
          /**
           * Use this method to perform clicks on menu items.
           *
           * It will assert the existence of the identifier. If the identifier exists but is not
           * a menu item then the assertion will succeed, but no click will be performed.
           *
           * Will also advance the clock millis milliseconds and run
           * enqueued Runnable scheduled to run on main looper in that timeframe.
           * Default value for millis is 500
           *
           */
          fun Activity.clickMenuItemAndRun(idString: String, millis: Long = 500): Int {
              val clock = SystemClock.currentGnssTimeClock()
              val timeBeforeClick = clock.millis()
              val identifier = resources.getIdentifier(idString, "id", packageName)
      
              assertTrue(
                  "The identifier with idString \"$idString\" was not found",
                  identifier != 0
              )
      
              shadowActivity.clickMenuItem(identifier)
              val timeAfterClick = clock.millis()
      
              shadowLooper.idleFor(Duration.ofMillis(millis- (timeAfterClick - timeBeforeClick)))
              val timeAfterIdle = clock.millis()
              return (timeAfterIdle - timeBeforeClick).toInt()
          }
      
          /**
           *  Retrieve last shown AlertDialog.
           *
           *  Will only find android.app.AlertDialog and not androidx.appcompat.app.AlertDialog
           *
           *  Returns the AlertDialog instance paired with its shadow
           */
          fun getLastAlertDialogWithShadow(errorMessageNotFound: String) : Pair<AlertDialog, ShadowAlertDialog> {
              val latestDialog:  AlertDialog? = ShadowAlertDialog.getLatestAlertDialog()
      
              assertNotNull("$errorMessageNotFound$ Make sure you are using android.app.AlertDialog", latestDialog)
      
              return latestDialog!! to Shadow.extract(latestDialog)
          }
      
          /**
           *  Makes assertions on the contents of the RecyclerView.
           *
           *  Asserts that the size matches the size of fakeResultList and then
           *  calls assertItems for each item of the list with the itemViewSupplier
           *  so that it is possible to make assertions on that itemView.
           *
           *  Take attention to refresh references to views coming from itemView since RecyclerView
           *  can change the instance of View for a determinate list item after an update to the list.
           */
          fun <T> RecyclerView.assertListItems(
              fakeResultList: List<T>,
              assertItems: (itemViewSupplier: () -> View, position: Int, item: T) -> Unit
          ) : Unit {
      
              assertNotNull("Your recycler view adapter should not be null", this.adapter)
      
              val expectedSize = fakeResultList.size
      
              val actualSize = this.adapter!!.itemCount
              assertEquals("Incorrect number of list items", expectedSize, actualSize)
      
              if(expectedSize == 0) {
                  return
              } else if(expectedSize > 0) {
                  val firstItemViewHolder = (0 until expectedSize)
                      .asSequence()
                      .mapNotNull {  this.findViewHolderForAdapterPosition(it) }
                      .firstOrNull()
                      ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")
      
                  val listHeight = firstItemViewHolder.itemView.height * (expectedSize + 1)
      
                  for((i, song) in fakeResultList.withIndex()) {
                      // setting height to ensure that all items are inflated. Height might change after assertItems, keep statement inside loop.
                      this.layout(0,0, this.width, listHeight)  // may increase clock time
      
                      val itemViewSupplier = {
                          scrollToPosition(i)
                          findViewHolderForAdapterPosition(i)?.itemView
                              ?: throw AssertionError("Could not find list item with index $i")
                      }
                      assertItems(itemViewSupplier, i, song)
                  }
      
              } else {
                  throw IllegalStateException("size assertion was not effective")
              }
          }
      
          /**
           *  Makes assertions on the contents of the RecyclerView.
           *
           *  Asserts that the size matches the size of fakeResultList and then
           *  calls assertItems for each item of the list with the itemViewSupplier
           *  so that it is possible to make assertions on that itemView.
           *
           *  Take attention to refresh references to views coming from itemView since RecyclerView
           *  can change the instance of View for a determinate list item after an update to the list.
           *
           *  This version also includes elapsedTime on the callBack to help keep track of time
           *  since the clock might advance
           */
          fun <T> RecyclerView.assertListItems(
              fakeResultList: List<T>,
              assertItems: (itemViewSupplier: () -> View, position: Int, item: T, elapsedTime: Int) -> Unit
          ) : Unit {
      
              assertNotNull("Your recycler view adapter should not be null", this.adapter)
      
              val expectedSize = fakeResultList.size
      
              val actualSize = this.adapter!!.itemCount
              assertEquals("Incorrect number of list items", expectedSize, actualSize)
      
              if(expectedSize > 0) {
                  val firstItemViewHolder = (0 until expectedSize)
                      .asSequence()
                      .mapNotNull {  this.findViewHolderForAdapterPosition(it) }
                      .firstOrNull()
                      ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")
      
                  val listHeight = firstItemViewHolder.itemView.height * (expectedSize + 1)
      
                  for((i, song) in fakeResultList.withIndex()) {
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      // setting height to ensure that all items are inflated. Height might change after assertItems, keep statement inside loop.
                      this.layout(0,0, this.width, listHeight)  // may increase clock time
      
                      val itemViewSupplier = {
                          scrollToPosition(i)
                          findViewHolderForAdapterPosition(i)?.itemView
                              ?: throw AssertionError("Could not find list item with index $i")
                      }
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      assertItems(itemViewSupplier, i, song, (timeAfter -  timeBefore).toInt())
                  }
      
              } else {
                  throw IllegalStateException("size assertion was not effective")
              }
          }
      
          /**
           *  Makes assertions on the contents of one item of the RecyclerView.
           *
           *  Asserts that the the size of the list is at least itemIndex + 1.
           *
           *  Calls assertItem with the itemViewSupplier so that it is possible to make assertions on that itemView.
           *  Take attention to refresh references to views coming from itemView since RecyclerView
           *  can change the instance of View for a determinate list item after an update to the list.
           */
          fun RecyclerView.assertSingleListItem(itemIndex: Int, assertItem: (itemViewSupplier: () -> View) -> Unit) {
      
              assertNotNull("Your recycler view adapter should not be null", this.adapter)
      
              val expectedMinSize = itemIndex + 1
      
              val actualSize = this.adapter!!.itemCount
              assertTrue(
                  "RecyclerView was expected to contain item with index $itemIndex, but its size was $actualSize",
                  actualSize >= expectedMinSize
              )
      
              if(actualSize >= expectedMinSize) {
                  val firstItemViewHolder = (0 until actualSize)
                      .asSequence()
                      .mapNotNull {  this.findViewHolderForAdapterPosition(it) }
                      .firstOrNull()
                      ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")
      
                  val listHeight = firstItemViewHolder.itemView.height * (expectedMinSize + 1)
                  this.layout(0,0, this.width, listHeight)  // may increase clock time
      
                  val itemViewSupplier = {
                      this.scrollToPosition(itemIndex)
                      val itemView = (this.findViewHolderForAdapterPosition(itemIndex)?.itemView
                          ?: throw AssertionError("Could not find list item with index $itemIndex"))
                      itemView
      
                  }
      
                  assertItem(itemViewSupplier)
      
              } else {
                  throw IllegalStateException("size assertion was not effective")
              }
          }
      
      
          fun ShadowAlertDialog.clickAndRunOnItem(itemIndex: Int, millis: Long = 500): Int {
              val timeBeforeClick = SystemClock.currentGnssTimeClock().millis()
              this.clickOnItem(itemIndex) // might or might not increase clock time
              val timeAfterClick = SystemClock.currentGnssTimeClock().millis()
              shadowLooper.idleFor(Duration.ofMillis(millis - (timeAfterClick - timeBeforeClick)))
              val timeAfterIdle = SystemClock.currentGnssTimeClock().millis()
      
              assertTrue(
                  "After click on AlertDialog item the dialog should be dismissed",
                  this.hasBeenDismissed()
              )
      
              return (timeAfterIdle - timeBeforeClick).toInt()
          }
      
      
          fun Int.timeString(): String {
              return "%02d:%02d".format(this / 60_000, this % 60_000 / 1000)
          }
      
          fun View.assertBackgroundColor(errorMessage:String, @ColorInt expectedBackgroundColor: Int, ) {
      
              assertTrue("Expected background to be ColorDrawable but was not. $errorMessage", this.background is ColorDrawable)
      
              val actualBackgroundColor = (this.background as ColorDrawable).color
      
              assertTrue(errorMessage, expectedBackgroundColor == actualBackgroundColor)
          }
      
          fun Drawable.assertCreatedFromResourceId(errorMessage: String, expectedId:  Int) {
              val actualId = Shadows.shadowOf(this).createdFromResId
              assertTrue(errorMessage, expectedId == actualId)
          }
      
          fun List<Int>.clickSongSelectorListItems(listView: RecyclerView): Int {
              val timeBefore = SystemClock.currentGnssTimeClock().millis()
      
              val maxIndex = max(this)
      
              assertNotNull("Your recycler view adapter should not be null", listView.adapter)
      
              val expectedMinSize = maxIndex + 1
      
              val actualSize = listView.adapter!!.itemCount
              assertTrue(
                  "RecyclerView was expected to contain item with index $maxIndex, but its size was $actualSize",
                  actualSize >= expectedMinSize
              )
      
              if(actualSize >= expectedMinSize) {
      
                  val firstItemViewHolder = (0 until actualSize)
                      .asSequence()
                      .mapNotNull {  listView.findViewHolderForAdapterPosition(it) }
                      .firstOrNull()
                      ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")
      
                  this.forEach { i ->
                      // setting height to ensure that all items are inflated
                      listView.layout(0,0, listView.width, firstItemViewHolder.itemView.height * (expectedMinSize + 1))
                      listView.scrollToPosition(i)
                      shadowLooper.idleFor(5, TimeUnit.MILLISECONDS)
      
                      var itemView = listView.findViewHolderForAdapterPosition(i)!!.itemView
      
                      var checkBox =
                          itemView.findViewByString<CheckBox>("songSelectorItemCheckBox")
      
                      assertEquals(
                          "songSelectorItemCheckBox should not be checked after clicks on mainMenuItemIdAddPlaylist",
                          false,
                          checkBox.isChecked
                      )
      
                      itemView.clickAndRun(5)
      
                      itemView = listView.findViewHolderForAdapterPosition(i)!!.itemView
                      checkBox = itemView.findViewByString<CheckBox>("songSelectorItemCheckBox")
      
                      assertEquals(
                          "songSelectorItemCheckBox should be checked after clicks on the list item",
                          true,
                          checkBox.isChecked
                      )
      
                      itemView.assertBackgroundColor(
                          "SongSelector list items should change color to Color.LTGRAY when item is selected",
                          Color.LTGRAY
                      )
                  }
      
                  val timeAfter = SystemClock.currentGnssTimeClock().millis()
                  return (timeAfter - timeBefore).toInt()
      
              } else {
                  throw IllegalStateException("size assertion was not effective")
              }
          }
      
          fun assertSongItem(errorMessage: String, itemView: View, song: SongFake) {
              val songItemTvArtist = itemView.findViewByString<TextView>("songItemTvArtist")
              val songItemTvTitle = itemView.findViewByString<TextView>("songItemTvTitle")
              val songItemTvDuration = itemView.findViewByString<TextView>("songItemTvDuration")
      
              assertEquals(errorMessage, song.artist, songItemTvArtist.text.toString())
              assertEquals(errorMessage, song.title, songItemTvTitle.text.toString())
              assertEquals(errorMessage, song.duration.timeString(), songItemTvDuration.text.toString())
          }
      
          fun assertViewStateIsPlayMusicState(
              songList: RecyclerView,
              fragmentContainer: FragmentContainerView
          ) {
      
              songList.assertSingleListItem(0){ itemView ->
                  itemView().findViewByString<ImageButton>("songItemImgBtnPlayPause")
              }
              fragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
          }
      
          fun addPlaylist(
              playlistName: String,
              selectedItemsIndex: List<Int>,
              songListView: RecyclerView,
              fragmentContainer: FragmentContainerView,
              testEmptyName: Boolean = false
          ): Int {
              val timeBefore = SystemClock.currentGnssTimeClock().millis()
              selectedItemsIndex.clickSongSelectorListItems(songListView) // might or might not increase clock time
      
              val addPlaylistButtonOk =
                  fragmentContainer.findViewByString<Button>("addPlaylistBtnOk")
      
              if(testEmptyName) {
                  addPlaylistButtonOk.clickAndRun(0) // might or might not increase clock time
      
                  assertLastToastMessageEquals(
                      errorMessage = "When addPlaylistEtPlaylistName is empty a toast message is expected after click on addPlaylistBtnOk",
                      expectedMessage = "Add a name to your playlist"
                  )
              }
      
              val addPlaylistEtPlaylistName =
                  fragmentContainer.findViewByString<EditText>("addPlaylistEtPlaylistName")
              addPlaylistEtPlaylistName.setText(playlistName)
      
              addPlaylistButtonOk.clickAndRun(0) // might or might not increase clock time
              assertViewStateIsPlayMusicState(songListView, fragmentContainer)
              val timeAfter = SystemClock.currentGnssTimeClock().millis()
              return (timeAfter - timeBefore).toInt()
          }
      
          fun loadPlaylist(menuItemIdLoadPlaylist: String, expectedPlaylistNameList: List<String>, playlistToLoadIndex: Int): Int {
              val timeBefore = SystemClock.currentGnssTimeClock().millis()
              activity.clickMenuItemAndRun(menuItemIdLoadPlaylist) // might or might not increase clock time
      
              getLastAlertDialogWithShadow(
                  "An AlertDialog should be displayed after click on mainMenuItemLoadPlaylist"
              ).also { (dialog, shadowDialog) ->
                  val dialogItems = shadowDialog.items.map { it.toString() }
      
                  assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemLoadPlaylist",
                      expectedPlaylistNameList,
                      dialogItems
                  )
                  shadowDialog.clickAndRunOnItem(playlistToLoadIndex, millis = 0) // might or might not increase clock time
              }
              val timeAfter = SystemClock.currentGnssTimeClock().millis()
              return (timeAfter - timeBefore).toInt()
          }
      
          inner class ControllerViews(
              val currentTv: TextView,
              val totalTv: TextView,
              val seekBar: SeekBar,
              val btnPlayPause: Button,
              val btnStop: Button
          ) {
              fun assertControllerState(errorMessage: String, songFake: SongFake, expectedPosition: Int) {
      
                  val messageTotalTimeTv = "$errorMessage On controllerTvTotalTime text"
                  assertEquals(messageTotalTimeTv, songFake.duration.timeString(), this.totalTv.text.toString())
      
                  val messageSeekBar = "$errorMessage On controllerSeekBar progress"
                  assertEquals(messageSeekBar, expectedPosition / 1000, this.seekBar.progress)
      
                  val messageCurrentTimeTv = "$errorMessage On controllerTvCurrentTime text"
                  assertEquals(messageCurrentTimeTv, expectedPosition.timeString(), this.currentTv.text.toString())
              }
          }
      
          fun FragmentContainerView.getControllerViews(): ControllerViews {
      
              return ControllerViews(
                  currentTv = findViewByString("controllerTvCurrentTime"),
                  totalTv=  findViewByString("controllerTvTotalTime"),
                  seekBar = findViewByString("controllerSeekBar"),
                  btnPlayPause = findViewByString("controllerBtnPlayPause"),
                  btnStop = findViewByString("controllerBtnStop")
              )
          }
      
          fun MediaPlayer.assertControllerPlay(errorMessage: String, controllerViews: ControllerViews, expectedPosition: Int) {
              assertController(errorMessage, controllerViews, expectedPosition, expectedIsPlaying = true)
          }
      
          fun MediaPlayer.assertControllerPause(errorMessage: String, controllerViews: ControllerViews, expectedPosition: Int) {
              assertController(errorMessage, controllerViews, expectedPosition, expectedIsPlaying = false)
          }
      
          fun MediaPlayer.assertControllerStop(errorMessage: String, controllerViews: ControllerViews) {
              assertController(errorMessage, controllerViews, expectedPosition = 0, expectedIsPlaying = false)
          }
      
          private fun MediaPlayer.assertController(
              errorMessage: String, controllerViews: ControllerViews, expectedPosition: Int, expectedIsPlaying: Boolean) {
      
              assertEquals("$errorMessage On mediaPlayer isPlaying", expectedIsPlaying, isPlaying)
      
              val messageCurrentPosition = "$errorMessage On mediaPlayer currentPosition expected: $expectedPosition found: $currentPosition"
              assertTrue(messageCurrentPosition, abs(expectedPosition - currentPosition) < 100)
      
              val messageSeekBar = "$errorMessage On controllerSeekBar progress"
              assertEquals(messageSeekBar, expectedPosition / 1000, controllerViews.seekBar.progress)
      
              val messageCurrentTimeTv = "$errorMessage On controllerTvCurrentTime text"
              assertEquals(messageCurrentTimeTv, expectedPosition.timeString(), controllerViews.currentTv.text.toString())
          }
      
          fun adjustPlayerPositionToAvoidSyncIssues(): Int {
              // tests can have sync problems with solutions depending on which position the player is paused
              // to avoid issues we adjust player position before pausing if the player position can be in inconvenient position
              // this is only needed if playingTime had some change without hardcoded values
      
              val syncAdjustment = 1000 - (player.currentPosition % 1000) + 200
              shadowLooper.idleFor(Duration.ofMillis(syncAdjustment.toLong()))
              return syncAdjustment
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/internals/SongFake.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer.internals
      // version 1.3
      data class SongFake(
          val id: Int,
          val artist: String,
          val title: String,
          val duration: Int
      )
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/Stage1UnitTestB.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer
      
      import android.app.AlertDialog
      import android.widget.Button
      import android.widget.SeekBar
      import android.widget.TextView
      import androidx.fragment.app.FragmentContainerView
      import androidx.recyclerview.widget.RecyclerView
      
      import org.hyperskill.musicplayer.internals.CustomShadowAsyncDifferConfig
      import org.hyperskill.musicplayer.internals.CustomMediaPlayerShadow
      import org.hyperskill.musicplayer.internals.MusicPlayerUnitTests
      import org.junit.Assert.assertEquals
      import org.junit.Ignore
      import org.junit.Test
      import org.junit.runner.RunWith
      import org.robolectric.RobolectricTestRunner
      import org.robolectric.Shadows
      import org.robolectric.annotation.Config
      
      // version 1.4
      @RunWith(RobolectricTestRunner::class)
      @Config(shadows = [CustomMediaPlayerShadow::class, CustomShadowAsyncDifferConfig::class])
      class Stage1UnitTestB : MusicPlayerUnitTests<MainActivity>(MainActivity::class.java){
      
          private val mainButtonSearch by lazy {
              val view = activity.findViewByString<Button>("mainButtonSearch")
      
              val expectedText = "search"
              val actualText = view.text.toString().lowercase()
              assertEquals("wrong text for mainButtonSearch", expectedText, actualText)
      
              view
          }
      
          private val mainSongList by lazy {
              activity.findViewByString<RecyclerView>("mainSongList")
          }
      
          private val mainFragmentContainer by lazy {
              activity.findViewByString<FragmentContainerView>("mainFragmentContainer")
          }
      
          val mainMenuItemIdAddPlaylist = "mainMenuAddPlaylist"
          val mainMenuItemIdLoadPlaylist = "mainMenuLoadPlaylist"
          val mainMenuItemIdDeletePlaylist = "mainMenuDeletePlaylist"
      
      
          @Test
          fun checkMainActivityComponentsExist() {
              testActivity {
                  mainButtonSearch
                  mainSongList
                  mainFragmentContainer
              }
          }
      
          @Test
          fun checkPlayerControllerFragmentComponentsExist() {
              testActivity {
                  mainFragmentContainer
      
                  val controllerTvCurrentTime =
                          mainFragmentContainer.findViewByString<TextView>("controllerTvCurrentTime")
      
      
                  val actualCurrentTime = controllerTvCurrentTime.text.toString()
                  val expectedCurrentTime = "00:00"
                  val messageWrongInitialCurrentTime = "Wrong initial value for controllerTvCurrentTime"
                  assertEquals(messageWrongInitialCurrentTime, expectedCurrentTime, actualCurrentTime)
      
                  val controllerTvTotalTime =
                          mainFragmentContainer.findViewByString<TextView>("controllerTvTotalTime")
      
      
                  val actualTotalTime = controllerTvTotalTime.text.toString()
                  val expectedTotalTime = "00:00"
                  val messageWrongInitialTotalTime = "Wrong initial value for controllerTvTotalTime"
                  assertEquals(messageWrongInitialTotalTime, expectedTotalTime, actualTotalTime)
      
                  mainFragmentContainer.findViewByString<SeekBar>("controllerSeekBar")
      
                  val controllerBtnPlayPause =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
      
                  val actualBtnPlayPauseText = controllerBtnPlayPause.text.toString().lowercase()
                  val expectedBtnPlayPauseText = "play/pause"
                  val messageWrongInitialBtnPlayPauseText = "Wrong initial value for controllerBtnPlayPause"
                  assertEquals(messageWrongInitialBtnPlayPauseText, expectedBtnPlayPauseText, actualBtnPlayPauseText)
      
                  val controllerBtnStop =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
                  val actualBtnStopText = controllerBtnStop.text.toString().lowercase()
                  val expectedBtnStopText = "stop"
                  val messageWrongInitialBtnStopText = "Wrong initial value for controllerBtnStop"
                  assertEquals(messageWrongInitialBtnStopText, expectedBtnStopText, actualBtnStopText)
              }
          }
      
          @Ignore
          @Test
          fun checkSearchButtonNoSongsFound() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
                  assertLastToastMessageEquals(
                          "wrong toast message after click to mainButtonSearch",
                          "no songs found"
                  )
              }
          }
      
          @Test
          fun checkMenuItemAddPlaylistWithNoSongs() {
              testActivity {
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  assertLastToastMessageEquals(
                          "wrong toast message after click to mainMenuItemIdAddPlaylist",
                          "no songs loaded, click search to load songs"
                  )
              }
          }
      
      
      
          @Test
          fun checkMenuItemLoadPlaylist() {
              testActivity {
                  activity.clickMenuItemAndRun(mainMenuItemIdLoadPlaylist)
      
                  val (alertDialog, shadowAlertDialog) = getLastAlertDialogWithShadow(
                          errorMessageNotFound = "No Dialog was shown after click on mainMenuLoadPlaylist."
                  )
      
                  val actualTitle = shadowAlertDialog.title.toString().lowercase()
                  val messageWrongTitle =
                          "Wrong title found on dialog shown after click on mainMenuLoadPlaylist"
                  val expectedTitle = "choose playlist to load"
                  assertEquals(messageWrongTitle, expectedTitle, actualTitle)
      
      
                  alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).clickAndRun()
              }
          }
      
          @Test
          fun checkMenuItemDeletePlaylist() {
              testActivity {
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
      
                  val (alertDialog, shadowAlertDialog) = getLastAlertDialogWithShadow(
                          errorMessageNotFound = "No Dialog was shown after click on mainMenuDeletePlaylist."
                  )
      
                  val actualTitle = shadowAlertDialog.title.toString().lowercase()
                  val messageWrongTitle =
                          "Wrong title found on dialog shown after click on mainMenuDeletePlaylist"
                  val expectedTitle = "choose playlist to delete"
                  assertEquals(messageWrongTitle, expectedTitle, actualTitle)
      
      
                  alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).clickAndRun()
              }
          }
      
          @Test
          fun checkControllerStopButtonBeforeSearch() {
      
              testActivity {
                  mainFragmentContainer
      
                  val controllerBtnStop =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
      
                  controllerBtnStop.clickAndRun()
                  // should not throw Exception
              }
          }
      
          @Test
          fun checkControllerSeekBarBeforeSearch() {
      
              testActivity {
                  mainFragmentContainer
      
                  val controllerSeekBar =
                          mainFragmentContainer.findViewByString<SeekBar>("controllerSeekBar")
      
                  if(Shadows.shadowOf(controllerSeekBar).onSeekBarChangeListener != null) {
                      controllerSeekBar.setProgressAsUser(1)
                      //should not throw exception
                  } else {
                      // ok
                  }
      
              }
          }
      
          @Test
          fun checkControllerPlayPauseButtonBeforeSearch() {
      
              testActivity {
                  mainFragmentContainer
      
                  val controllerBtnPlayPause =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
      
                  controllerBtnPlayPause.clickAndRun()
                  // should not throw Exception
              }
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/Stage2UnitTest.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer
      
      import android.Manifest
      import android.app.AlertDialog
      import android.graphics.Color
      import android.widget.*
      import androidx.fragment.app.FragmentContainerView
      import androidx.recyclerview.widget.RecyclerView
      
      import org.hyperskill.musicplayer.internals.CustomMediaPlayerShadow
      import org.hyperskill.musicplayer.internals.CustomShadowAsyncDifferConfig
      import org.hyperskill.musicplayer.internals.MusicPlayerUnitTests
      import org.hyperskill.musicplayer.internals.SongFake
      import org.junit.Assert.assertEquals
      import org.junit.Before
      import org.junit.Test
      import org.junit.runner.RunWith
      import org.robolectric.RobolectricTestRunner
      import org.robolectric.annotation.Config
      import java.util.concurrent.TimeUnit
      
      // version 1.4
      @Config(shadows = [CustomMediaPlayerShadow::class, CustomShadowAsyncDifferConfig::class])
      @RunWith(RobolectricTestRunner::class)
      class Stage2UnitTest : MusicPlayerUnitTests<MainActivity>(MainActivity::class.java){
      
          companion object {
              const val mainMenuItemIdAddPlaylist = "mainMenuAddPlaylist"
              const val mainMenuItemIdLoadPlaylist = "mainMenuLoadPlaylist"
              const val mainMenuItemIdDeletePlaylist = "mainMenuDeletePlaylist"
      
              val songFakeList = (1..10).map { idNum ->
                  SongFake(
                          id = idNum,
                          artist = "artist$idNum",
                          title = "title$idNum",
                          duration = 215_000
                  )
              }
          }
      
          private val mainButtonSearch by lazy {
              val view = activity.findViewByString<Button>("mainButtonSearch")
      
              val expectedText = "search"
              val actualText = view.text.toString().lowercase()
              assertEquals("wrong text for mainButtonSearch", expectedText, actualText)
      
              view
          }
      
          private val mainSongList by lazy {
              activity.findViewByString<RecyclerView>("mainSongList")
          }
      
          private val mainFragmentContainer by lazy {
              activity.findViewByString<FragmentContainerView>("mainFragmentContainer")
          }
      
          @Before
          fun setUp() {
              setupContentProvider(songFakeList)
              shadowActivity.grantPermissions(Manifest.permission.READ_EXTERNAL_STORAGE)
              CustomMediaPlayerShadow.setFakeSong(songFakeList[0])
          }
      
      
          @Test
          fun checkSongListAfterInitialClickOnSearch() {
      
              testActivity {
                  shadowActivity.grantPermissions(Manifest.permission.READ_EXTERNAL_STORAGE)
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
      
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, index, songFake ->
                      assertSongItem("Wrong data after search.", itemViewSupplier(), songFake)
      
                      val songItemImgBtnPlayPause: ImageButton =
                              itemViewSupplier().findViewByString("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is stopped " +
                                      "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkSongListItemChangesImageOnImageButtonClick() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  val songFakeIndex = 3
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndex])
      
                  mainSongList.assertSingleListItem(songFakeIndex) { itemViewSupplier ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is stopped " +
                                      "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a stopped song " +
                                      "the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a playing song " +
                                      "the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkWhenCurrentTrackChangesAndOldCurrentTrackIsPlayingImageChangesToPaused() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  val songFakeIndexBefore = 5
                  val songFakeIndexAfter = 7
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndexBefore])
                  mainSongList.assertSingleListItem(songFakeIndexBefore) { itemViewSupplierBefore ->
                      var songItemImgBtnPlayPauseBefore =
                              itemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is stopped " +
                                      "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPauseBefore.clickAndRun()
                      songItemImgBtnPlayPauseBefore =
                              itemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a stopped song" +
                                      " the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndexAfter])
                      shadowLooper.idleFor(10_000L, TimeUnit.MILLISECONDS)
                      mainSongList.assertSingleListItem(songFakeIndexAfter) { itemViewSupplierAfter ->
                          var songItemImgBtnPlayPauseAfter =
                                  itemViewSupplierAfter().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                          songItemImgBtnPlayPauseAfter.drawable.assertCreatedFromResourceId(
                                  "When a song from the song list is stopped " +
                                          "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPauseAfter.clickAndRun()
                          songItemImgBtnPlayPauseAfter =
                                  itemViewSupplierAfter().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                          songItemImgBtnPlayPauseAfter.drawable.assertCreatedFromResourceId(
                                  "After clicking on songItemPlayPauseImgBtn on a paused song " +
                                          "the image displayed should change to R.drawable.ic_pause",
                                  R.drawable.ic_pause
                          )
      
                      }
                      songItemImgBtnPlayPauseBefore =
                              itemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "After changing the currentTrack with the old currentTrack playing" +
                                      "the image displayed on the old currentTrack should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkWhenCurrentTrackChangesAndOldCurrentTrackIsNotPlayingImageRemains() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  val songFakeIndexBefore = 5
                  val songFakeIndexAfter = 7
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndexBefore])
                  mainSongList.assertSingleListItem(songFakeIndexBefore) { ItemViewSupplierBefore ->
                      var songItemImgBtnPlayPauseBefore =
                              ItemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is paused the image of songItemPlayPauseImgBtn " +
                                      "should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPauseBefore.clickAndRun()
                      songItemImgBtnPlayPauseBefore =
                              ItemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a paused song " +
                                      "the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      songItemImgBtnPlayPauseBefore.clickAndRun()
                      songItemImgBtnPlayPauseBefore =
                              ItemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a playing song " +
                                      "the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndexAfter])
                      mainSongList.assertSingleListItem(songFakeIndexAfter) { itemViewSupplierAfter ->
                          var songItemImgBtnPlayPauseAfter =
                                  itemViewSupplierAfter().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                          songItemImgBtnPlayPauseAfter.drawable.assertCreatedFromResourceId(
                                  "When a song from the song list is paused " +
                                          "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPauseAfter.clickAndRun()
                          songItemImgBtnPlayPauseAfter =
                                  itemViewSupplierAfter().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                          songItemImgBtnPlayPauseAfter.drawable.assertCreatedFromResourceId(
                                  "After clicking on songItemPlayPauseImgBtn on a paused song " +
                                          "the image displayed should change to R.drawable.ic_pause",
                                  R.drawable.ic_pause
                          )
      
                      }
      
                      songItemImgBtnPlayPauseBefore =
                              ItemViewSupplierBefore().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPauseBefore.drawable.assertCreatedFromResourceId(
                              "After changing the currentTrack with the old currentTrack not playing " +
                                      "the image displayed should remain being R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkAfterInitialSearchFirstListItemIsCurrentTrackAndRespondToControllerPlayPauseButton() {
      
              testActivity {
                  mainButtonSearch
                  mainFragmentContainer
      
                  val controllerBtnPlayPause =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
      
                  mainButtonSearch.clickAndRun()
      
      
                  mainSongList.assertSingleListItem(0) { itemViewSupplier ->
      
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is paused " +
                                      "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
      
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a paused song" +
                                      " the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      controllerBtnPlayPause.clickAndRun()
      
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a playing song" +
                                      " the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkCurrentTrackImgChangeAfterControllerStopButtonClickWithCurrentTrackPlaying() {
      
              testActivity {
                  mainButtonSearch
                  mainFragmentContainer
      
                  val songFakeIndex = 4
      
                  val controllerBtnStop =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
      
                  mainButtonSearch.clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndex])
                  mainSongList.assertSingleListItem(songFakeIndex) { itemViewSupplier ->
      
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is stopped " +
                                      "the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a stopped song " +
                                      "the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      controllerBtnStop.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnStop on a playing song " +
                                      "the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemImgBtnPlayPause on a stopped song " +
                                      "the image of songItemPlayPauseImgBtn should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemImgBtnPlayPause on a playing song" +
                                      "the image of songItemPlayPauseImgBtn should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      controllerBtnStop.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnStop on a paused song " +
                                      "the image displayed should remain R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      controllerBtnStop.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnStop on a stopped song " +
                                      "the image displayed should remain R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkListItemImgChangeMixedClicks() {
      
              testActivity {
                  mainButtonSearch
                  mainFragmentContainer
      
                  val songFakeIndex = 6
      
                  val controllerBtnStop =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
                  val controllerBtnPlayPause =
                          mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
      
                  mainButtonSearch.clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[songFakeIndex])
                  mainSongList.assertSingleListItem(songFakeIndex) { listItemViewSupplier ->
      
                      var songItemImgBtnPlayPause = listItemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      for(i in 1..10) {
                          /*
                              1 - paused -> songItemImgBtnPlayPause -> playing
                              2 - playing -> controllerBtnPlayPause -> paused
                              3 - paused -> controllerBtnPlayPause -> playing
                              4 - playing -> songItemImgBtnPlayPause -> paused
                              5 - paused -> controllerBtnPlayPause -> playing
                              6 - playing -> controllerBtnStop -> paused
                              7 - paused -> songItemImgBtnPlayPause -> playing
                              8 - playing -> controllerBtnPlayPause -> paused
                              9 - paused -> controllerBtnPlayPause -> playing
                              10 - playing -> songItemImgBtnPlayPause -> paused
                           */
      
                          val buttonClickedId = if(i == 6) {
                              controllerBtnStop.clickAndRun()
                              songItemImgBtnPlayPause = listItemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                              songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                      "After clicking on controllerBtnStop on a playing song the image displayed should change to R.drawable.ic_play",
                                      R.drawable.ic_play
                              )
                              continue
                          } else if(i % 3 == 1) {
                              songItemImgBtnPlayPause.clickAndRun()
                              songItemImgBtnPlayPause = listItemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                              "songItemImgBtnPlayPause"
                          } else {
                              controllerBtnPlayPause.clickAndRun()
                              songItemImgBtnPlayPause = listItemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                              "controllerBtnPlayPause"
                          }
      
                          if(i % 2 == 1) {
                              songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                      "After clicking on $buttonClickedId on a paused song the image displayed should change to R.drawable.ic_pause",
                                      R.drawable.ic_pause
                              )
                          } else {
                              songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                      "After clicking on $buttonClickedId on a playing song the image displayed should change to R.drawable.ic_play",
                                      R.drawable.ic_play
                              )
                          }
                      }
                  }
              }
          }
      
          @Test
          fun checkAddPlaylistStateTriggeredByMenuItem() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, index, itemSongFake ->
                      val listItemView = itemViewSupplier()
                      // check songSelector items
                      val songItemTvTitle: TextView = listItemView.findViewByString("songSelectorItemTvTitle")
                      val songItemTvArtist: TextView = listItemView.findViewByString("songSelectorItemTvArtist")
                      val songItemTvDuration: TextView = listItemView.findViewByString("songSelectorItemTvDuration")
                      val songSelectorItemCheckBox: CheckBox = listItemView.findViewByString("songSelectorItemCheckBox")
      
                      val actualSongTitle = songItemTvTitle.text.toString()
                      assertEquals(
                              "songItemTvTitle with incorrect text",
                              actualSongTitle,
                              itemSongFake.title
                      )
      
                      val actualSongArtist = songItemTvArtist.text.toString()
                      assertEquals(
                              "songItemTvArtist with incorrect text",
                              actualSongArtist,
                              itemSongFake.artist
                      )
      
                      val actualSongDuration = songItemTvDuration.text.toString()
                      val expectedSongDuration = itemSongFake.duration.timeString()
                      assertEquals(
                              "songItemTvDuration with incorrect text",
                              expectedSongDuration,
                              actualSongDuration,
                      )
      
                      assertEquals(
                              "No songSelectorItemCheckBox should be checked after click on mainMenuItemIdAddPlaylist",
                              false,
                              songSelectorItemCheckBox.isChecked
                      )
      
                      listItemView.assertBackgroundColor(
                              errorMessage = "The backgroundColor for all songSelectorItems should be Color.WHITE after click on mainMenuItemIdAddPlaylist",
                              expectedBackgroundColor = Color.WHITE
                      )
                      //
                  }
      
                  mainFragmentContainer.findViewByString<Button>("addPlaylistBtnCancel").also { addPlaylistBtnCancel ->
                      assertEquals("Wrong text for addPlaylistBtnCancel", "cancel", addPlaylistBtnCancel.text.toString().lowercase())
                  }
                  mainFragmentContainer.findViewByString<Button>("addPlaylistBtnOk").also { addPlaylistBtnOk ->
                      assertEquals("Wrong text for addPlaylistBtnOk", "ok", addPlaylistBtnOk.text.toString().lowercase())
                  }
                  mainFragmentContainer.findViewByString<EditText>("addPlaylistEtPlaylistName").also { addPlaylistEtPlaylistName ->
                      assertEquals("Wrong hint for addPlaylistEtPlaylistName", "playlist name", addPlaylistEtPlaylistName.hint.toString().lowercase())
                  }
              }
          }
      
          @Test
          fun checkAddingPlaylistWithEmptyListAddedToastErrorEmptyListMessage() {
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "My Playlist"
      
                  val addPlaylistButtonOk =
                          mainFragmentContainer.findViewByString<Button>("addPlaylistBtnOk")
      
                  val addPlaylistEtPlaylistName =
                          mainFragmentContainer.findViewByString<EditText>("addPlaylistEtPlaylistName")
                  addPlaylistEtPlaylistName.setText(playlistName)
      
                  addPlaylistButtonOk.clickAndRun()
      
                  assertLastToastMessageEquals(
                          errorMessage = "When there is no song selected a toast message is expected after click on addPlaylistBtnOk",
                          expectedMessage = "Add at least one song to your playlist"
                  )
              }
          }
      
          @Test
          fun checkAddingPlaylistWithBothEmptyListAndEmptyPlaylistNameToastErrorEmptyListMessage() {
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val addPlaylistButtonOk =
                          mainFragmentContainer.findViewByString<Button>("addPlaylistBtnOk")
      
                  addPlaylistButtonOk.clickAndRun()
      
                  assertLastToastMessageEquals(
                          errorMessage = "When there is no song selected a toast message is expected after click on addPlaylistBtnOk",
                          expectedMessage = "Add at least one song to your playlist"
                  )
              }
          }
      
          @Test
          fun checkAddingPlaylistWithReservedPlaylistNameAllSongsToastErrorReservedNameMessage() {
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val addPlaylistButtonOk =
                          mainFragmentContainer.findViewByString<Button>("addPlaylistBtnOk")
      
                  val playlistName = "All Songs"
                  val addPlaylistEtPlaylistName =
                          mainFragmentContainer.findViewByString<EditText>("addPlaylistEtPlaylistName")
      
                  mainSongList.assertSingleListItem(0) {
                      it().clickAndRun()
                  }
      
                  addPlaylistEtPlaylistName.setText(playlistName)
                  addPlaylistButtonOk.clickAndRun()
      
                  assertLastToastMessageEquals(
                          errorMessage = "All Songs should be a reserve name. A toast with message",
                          expectedMessage = "All Songs is a reserved name choose another playlist name"
                  )
              }
          }
      
          @Test
          fun checkLoadPlaylistInPlayMusicStateAfterAddingPlaylistWithMainMenuItem() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val testedItemsOneBasedIndexes = listOf(2, 4, 7)
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  val playlistName = "My Playlist"
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                          testEmptyName = true
                  )
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes[0]])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  val playlistSongFake = songFakeList.filter { it.id in testedItemsOneBasedIndexes }
      
                  mainSongList.assertListItems(playlistSongFake) { itemViewSupplier, position, song ->
      
                      assertSongItem("Wrong list item after playlist loaded", itemViewSupplier(), song)
                      CustomMediaPlayerShadow.setFakeSong(song)
      
                      // check image changes after playlist loaded
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val controllerBtnPlayPause =
                              mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
                      val controllerBtnStop =
                              mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
      
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is paused the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a paused song the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
      
                      controllerBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnPlayPause on a playing song the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      controllerBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnPlayPause on a paused song the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      controllerBtnStop.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnStop on a playing song the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkLoadPlaylistInPlayMusicStateAfterAddingPlaylistWithLongClick() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(4, 7, 8)
                  val testedItemsOneBasedIndexes = testedItemsZeroBasedIndexes.map { it + 1 }
                  val longClickItemZeroBasedIndex = 5
                  val longClickItemOneBasedIndex = longClickItemZeroBasedIndex + 1
                  mainButtonSearch.clickAndRun()
      
                  mainSongList.assertSingleListItem(longClickItemZeroBasedIndex) {
                      it().clickLongAndRun()
                  }
      
                  // check long click item is checked and deselect item
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item ->
                      when(item.id) {
                          longClickItemOneBasedIndex -> {
                              val itemView = itemViewSupplier()
                              val songSelectorItemCheckBox =
                                      itemView.findViewByString<CheckBox>("songSelectorItemCheckBox")
      
                              assertEquals(
                                      "On the item that received a long click songSelectorItemCheckBox should be check.",
                                      true,
                                      songSelectorItemCheckBox.isChecked
                              )
      
                              itemView.assertBackgroundColor(
                                      "On the item that received a long click background color should be Color.LT_GRAY.",
                                      Color.LTGRAY
                              )
      
                              itemView.clickAndRun()  // deselect
                          }
                          else -> {}
                      }
                  }
                  //
      
                  val playlistName = "My Playlist"
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                          testEmptyName = true
                  )
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  val playlistSongFake = songFakeList.filter { it.id in testedItemsOneBasedIndexes }
      
                  mainSongList.assertListItems(playlistSongFake) { itemViewSupplier, position, song ->
      
                      assertSongItem("Wrong list item after playlist loaded", itemViewSupplier(), song)
                      CustomMediaPlayerShadow.setFakeSong(song)
      
                      // check image changes after load
                      val controllerBtnPlayPause =
                              mainFragmentContainer.findViewByString<Button>("controllerBtnPlayPause")
                      val controllerBtnStop =
                              mainFragmentContainer.findViewByString<Button>("controllerBtnStop")
      
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When a song from the song list is paused the image of songItemPlayPauseImgBtn should be R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemPlayPauseImgBtn on a paused song the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      controllerBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnPlayPause on a playing song the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
      
                      controllerBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnPlayPause on a paused song the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
      
                      controllerBtnStop.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on controllerBtnStop on a playing song the image displayed should change to R.drawable.ic_play",
                              R.drawable.ic_play
                      )
                      //
                  }
              }
          }
      
          @Test
          fun checkLoadPlaylistOnPlayMusicStateWithCurrentTrackKeepsCurrentTrack() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = testedItemsZeroBasedIndexes[1]
      
                  mainButtonSearch.clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemImgBtnPlayPause the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
                  }
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "My Playlist"
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // check item keeps selected state after list add
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(item.id == selectedSongZeroIndex + 1) {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain selected after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.btnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          controllerUi.btnStop.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnStop clicks after adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after adding a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
      
      
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // check item keeps selected state after list load
                  mainSongList.assertListItems(
                          testedItemsZeroBasedIndexes.map { songFakeList[it] }) { itemViewSupplier, position, item ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(item.id == selectedSongZeroIndex + 1) {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain selected after loading a playlist",
                                  R.drawable.ic_pause
                          )
      
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.btnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnPlayPause clicks after loading a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after loading a playlist",
                                  R.drawable.ic_pause
                          )
      
                          controllerUi.btnStop.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnStop clicks after loading a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after loading a playlist",
                                  R.drawable.ic_pause
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after loading a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkLoadPlaylistOnPlayMusicStateWithoutCurrentTrackChangesCurrentTrack() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = 8
      
                  mainButtonSearch.clickAndRun()
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemImgBtnPlayPause the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
                  }
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "My Playlist"
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // check item keeps selected state after list add
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(item.id == selectedSongZeroIndex + 1) {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain selected after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.btnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          controllerUi.btnStop.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to controllerBtnStop clicks after adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after adding a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // check default item selected after list load
                  mainSongList.assertListItems(
                          testedItemsZeroBasedIndexes.map { songFakeList[it] }) { itemViewSupplier, position, item ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(position == 0) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.btnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The first song should be the currentTrack after loading a playlist " +
                                          "without the old currentTrack and respond to controllerBtnPlayPause clicks",
                                  R.drawable.ic_pause
                          )
      
                          controllerUi.btnStop.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding " +
                                          "to controllerBtnStop clicks after loading a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding " +
                                          "to songItemImgBtnPlayPause clicks after loading a playlist",
                                  R.drawable.ic_pause
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A track that is not the currentTrack should remain not being the currentTrack",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkLoadPlaylistInAddPlaylistStateKeepsSelectedItemsById() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val playlistAItemsZeroBasedIndexes = listOf(0, 3, 6, 7, 8, 9)
                  val playlistAItemsOneBasedIndexes = playlistAItemsZeroBasedIndexes.map { it + 1 }
                  val playlistBItemsZeroBasedIndexes = playlistAItemsZeroBasedIndexes.filter { it % 3 ==  0 }
                  val playlistBItemsOneBasedIndexes = playlistBItemsZeroBasedIndexes.map { it + 1 }
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "Weird Sounds"
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = playlistAItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                  )
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  // check default playlist "All Songs" in ADD_PLAYLIST state and select items
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item ->
                      var itemView = itemViewSupplier()
                      var checkBox =
                              itemView.findViewByString<CheckBox>("songSelectorItemCheckBox")
      
                      assertEquals(
                              "No songSelectorItemCheckBox should be checked after click on mainMenuItemIdAddPlaylist",
                              false,
                              checkBox.isChecked
                      )
      
                      if(item.id in playlistBItemsOneBasedIndexes) {
                          itemView.clickAndRun()
                          itemView = itemViewSupplier()
                          checkBox = itemView.findViewByString<CheckBox>("songSelectorItemCheckBox")
      
      
                          assertEquals(
                                  "songSelectorItemCheckBox should be checked after click on list item",
                                  true,
                                  checkBox.isChecked
                          )
                      }
                  }
                  //
      
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // check loaded playlist in ADD_PLAYLIST state keeps selected items
                  mainSongList.assertListItems(
                          songFakeList.filter { it.id in playlistAItemsOneBasedIndexes }
                  ) { itemViewSupplier, position, item ->
      
                      val checkBox =
                              itemViewSupplier().findViewByString<CheckBox>("songSelectorItemCheckBox")
      
                      if(item.id in playlistBItemsOneBasedIndexes) {
                          assertEquals(
                                  "songSelectorItemCheckBox should remain isChecked value" +
                                          " after list loaded on ADD_PLAYLIST state",
                                  true,
                                  checkBox.isChecked
                          )
                      } else {
                          assertEquals(
                                  "songSelectorItemCheckBox should remain isChecked value" +
                                          " after list loaded on ADD_PLAYLIST state",
                                  false,
                                  checkBox.isChecked
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkLoadPlaylistInAddPlaylistStateKeepsCurrentTrackWhenReturningToPlayMusicState() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val playlistItemsZeroBasedIndexes = listOf(0, 3, 6, 7, 8, 9)
                  val selectedItem = 1
      
                  mainButtonSearch.clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedItem])
                  mainSongList.assertSingleListItem(selectedItem) { itemViewSupplier ->
                      itemViewSupplier()
                              .findViewByString<ImageButton>("songItemImgBtnPlayPause")
                              .clickAndRun()
                  }
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "Party Songs"
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = playlistItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                  )
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun()
      
                  mainSongList.assertListItems(songFakeList){ itemViewSupplier, position, song ->
                      assertSongItem(
                              "The currentPlaylist should not change " +
                                      "after loading a playlist in ADD_PLAYLIST state",
                              itemViewSupplier(), song
                      )
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(position == selectedItem) {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should keep its playing state " +
                                          "after loading a playlist on ADD_PLAYLIST state and returning to PLAY_MUSIC state",
                                  R.drawable.ic_pause
                          )
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A track that is not the currentTrack should not be playing",
                                  R.drawable.ic_play
                          )
                      }
                  }
              }
          }
      
          @Test
          fun checkPlaylistSavedAfterSelectingSongsAfterLoadingPlaylistInAddPlaylistState() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val playlistOne = listOf(1, 2, 3)
                  val selectItemsOne = listOf(0, 1)
                  val selectItemsTwo = listOf(2, 3)
      
                  mainButtonSearch.clickAndRun()
                  val playlistName1 = "playlist1"
                  val playlistName2 = "playlist2"
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  addPlaylist(
                          playlistName = playlistName1,
                          selectedItemsIndex = playlistOne,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
      
                  mainSongList.assertListItems(songFakeList) {itemViewSupplier, position, item ->
                      if(item.id - 1 in selectItemsOne) {
                          itemViewSupplier().clickAndRun()
                      }
                  }
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName1),
                          playlistToLoadIndex = 1
                  )
      
                  val loadPlaylistOneSongs = songFakeList.filter { it.id - 1 in playlistOne }
                  mainSongList.assertListItems(loadPlaylistOneSongs) {itemViewSupplier, position, item ->
                      if(item.id - 1 in selectItemsTwo) {
                          itemViewSupplier().clickAndRun()
                      }
                  }
                  mainFragmentContainer.findViewByString<EditText>("addPlaylistEtPlaylistName").apply {
                      setText(playlistName2)
                  }
                  mainFragmentContainer.findViewByString<Button>("addPlaylistBtnOk").clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[playlistOne.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName1, playlistName2),
                          playlistToLoadIndex = 2
                  )
                  val messageItemsSaved =
                          "The playlist saved should contain the selected items when clicking addPlaylistBtnOk"
                  mainSongList.assertListItems(loadPlaylistOneSongs) { itemViewSupplier, position, song ->
                      assertSongItem(messageItemsSaved, itemViewSupplier(), song)
                  }
              }
          }
      
          @Test
          fun checkCancellingAddPlaylistKeepsCurrentPlaylist() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val playlistAItemsZeroBasedIndexes = listOf(3, 7, 8)
                  val playlistAItemsOneBasedIndexes = playlistAItemsZeroBasedIndexes.map { it + 1 }
      
                  mainButtonSearch.clickAndRun()
                  val playlistName = "Cool Songs"
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = playlistAItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                          testEmptyName = true
                  )
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[playlistAItemsZeroBasedIndexes[0]])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // check loaded items
                  val playlistSongFake = songFakeList.filter { it.id in playlistAItemsOneBasedIndexes }
      
                  mainSongList.assertListItems(playlistSongFake) { itemViewSupplier, position, song ->
                      assertSongItem("Wrong list item after playlist loaded", itemViewSupplier(), song)
                  }
                  //
      
                  // canceling an add playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  mainFragmentContainer.findViewByString<Button>("addPlaylistBtnCancel").clickAndRun()
                  //
      
                  // check loaded items remains
                  mainSongList.assertListItems(playlistSongFake) { itemViewSupplier, position, item ->
                      val messageWrongListItemAfterCancel =
                              "Playlist loaded should remain after addPlaylistBtnCancel clicked"
                      assertSongItem(messageWrongListItemAfterCancel, itemViewSupplier(), item)
                  }
                  //
              }
          }
      
          @Test
          fun checkCancelingAddPlaylistKeepsCurrentTrackPlayingState() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = testedItemsZeroBasedIndexes[1]
      
                  mainButtonSearch.clickAndRun()
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.clickAndRun()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "After clicking on songItemImgBtnPlayPause " +
                                      "the image displayed should change to R.drawable.ic_pause",
                              R.drawable.ic_pause
                      )
                  }
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  mainFragmentContainer.findViewByString<Button>("addPlaylistBtnCancel").clickAndRun()
      
                  // check item keeps selected state after cancel add list
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if(item.id == selectedSongZeroIndex + 1) {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain being the currentTrack " +
                                          "after canceling adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.btnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding to controllerBtnPlayPause clicks " +
                                          "after canceling adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding to songItemImgBtnPlayPause clicks " +
                                          "after canceling adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                          controllerUi.btnStop.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding to controllerBtnStop clicks " +
                                          "after canceling adding a playlist",
                                  R.drawable.ic_play
                          )
      
                          songItemImgBtnPlayPause.clickAndRun()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "The currentTrack should remain responding to songItemImgBtnPlayPause clicks " +
                                          "after canceling adding a playlist",
                                  R.drawable.ic_pause
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A track that is not the currentTrack should remain not being " +
                                          "the currentTrack after canceling adding a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkDeletePlaylistOnPlayMusicStateDeletingPlaylistThatIsNotCurrentPlaylist() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  addPlaylist(
                          playlistName = "My Playlist",
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // delete playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf("My Playlist"),
                              dialogItems
                      )
                      shadowDialog.clickAndRunOnItem(0)
                  }
                  //
      
                  // check delete dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf<String>(),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check load dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdLoadPlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemLoadPlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemLoadPlaylist",
                              listOf("All Songs"),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  //check currentPlaylist remains
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      assertSongItem(
                              "Deleting a playlist that is not the currentPlaylist " +
                                      "should not change the currentPlaylist",
                              itemViewSupplier(), song
                      )
                  }
              }
          }
      
          @Test
          fun checkDeletePlaylistOnPlayMusicStateWithCurrentPlaylistBeingDeleted() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val testedItemsOneBasedIndexes = testedItemsZeroBasedIndexes.map { it + 1 }
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  val playlistName = "My Playlist"
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // check loaded items
                  val playlistSongFake = songFakeList.filter { it.id in testedItemsOneBasedIndexes }
      
                  mainSongList.assertListItems(playlistSongFake) { itemViewSupplier, position, item ->
                      val messageWrongListItemAfterPlaylistLoaded = "Wrong list item after playlist loaded"
                      assertSongItem(messageWrongListItemAfterPlaylistLoaded, itemViewSupplier(), item)
                  }
                  //
      
                  // delete playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf(playlistName),
                              dialogItems
                      )
                      shadowDialog.clickAndRunOnItem(0)
                  }
                  //
      
                  //check items
                  mainSongList.assertListItems(songFakeList) {itemViewSupplier, position, item ->
                      val messageWrongItem =
                              "Wrong list item found after deleting current playlist, " +
                                      "expected \"All songs\" playlist to be loaded"
                      assertSongItem(messageWrongItem, itemViewSupplier(), item)
                  }
      
                  // check delete dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals(
                              "Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf<String>(),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check load dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdLoadPlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemLoadPlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemLoadPlaylist",
                              listOf("All Songs"),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
              }
          }
      
          @Test
          fun checkDeletePlaylistOnAddPlaylistStateDeletingPlaylistThatIsNotDisplayingAndNotCurrentPlaylist() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  addPlaylist(
                          playlistName = "My Playlist",
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  // delete playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf("My Playlist"),
                              dialogItems
                      )
                      shadowDialog.clickAndRunOnItem(0)
                  }
                  //
      
                  // check delete dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf<String>(),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check load dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdLoadPlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemLoadPlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemLoadPlaylist",
                              listOf("All Songs"),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check SongSelector items remains
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      val itemView = itemViewSupplier()
                      val actualArtist = itemView
                              .findViewByString<TextView>("songSelectorItemTvArtist")
                              .text.toString().lowercase()
                      val actualTitle = itemView
                              .findViewByString<TextView>("songSelectorItemTvTitle")
                              .text.toString().lowercase()
                      val actualDuration = itemView
                              .findViewByString<TextView>("songSelectorItemTvDuration")
                              .text.toString().lowercase()
                      val errorMessage =
                              "After deleting in ADD_PLAYLIST state a playlist that is not displaying " +
                                      "the playlist that is displaying should remain"
      
                      assertEquals(errorMessage, song.artist, actualArtist)
                      assertEquals(errorMessage, song.title, actualTitle)
                      assertEquals(errorMessage, song.duration.timeString(), actualDuration)
                  }
      
                  mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun()
      
                  //check currentPlaylist remains
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      val errorMessage =
                              "After deleting in ADD_PLAYLIST state a playlist that is not the currentPlaylist" +
                                      "the currentPlaylist should remain"
      
                      assertSongItem(errorMessage, itemViewSupplier(), song)
                  }
              }
          }
      
          @Test
          fun checkDeletePlaylistOnAddPlaylistStateWithCurrentDisplayingAndCurrentPlaylistBeingDeleted() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val playlistName = "My Playlist"
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // load list in PLAY_MUSIC state
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
      
                  // load list in ADD_PLAYLIST state
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList.first())
                  // delete playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf(playlistName),
                              dialogItems
                      )
                      shadowDialog.clickAndRunOnItem(0)
                  }
                  //
      
                  // check delete dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdDeletePlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemDeletePlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemDeletePlaylist",
                              listOf<String>(),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check load dialog don't display deleted playlist
                  activity.clickMenuItemAndRun(mainMenuItemIdLoadPlaylist)
      
                  getLastAlertDialogWithShadow(
                          "An AlertDialog should be displayed after click on mainMenuItemLoadPlaylist"
                  ).also { (dialog, shadowDialog)  ->
                      val dialogItems = shadowDialog.items.map { it.toString() }
      
                      assertEquals("Wrong list displayed on AlertDialog after click on mainMenuItemLoadPlaylist",
                              listOf("All Songs"),
                              dialogItems
                      )
      
                      dialog.getButton(AlertDialog.BUTTON_NEGATIVE).clickAndRun()
                  }
                  //
      
                  // check SongSelector changes to "All Songs"
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      val itemView = itemViewSupplier()
                      val actualArtist = itemView
                              .findViewByString<TextView>("songSelectorItemTvArtist")
                              .text.toString().lowercase()
                      val actualTitle = itemView
                              .findViewByString<TextView>("songSelectorItemTvTitle")
                              .text.toString().lowercase()
                      val actualDuration = itemView
                              .findViewByString<TextView>("songSelectorItemTvDuration")
                              .text.toString().lowercase()
                      val errorMessage =
                              "After deleting in ADD_PLAYLIST state a playlist that is displaying " +
                                      "the playlist that is displaying should change to \"All Songs\""
      
                      assertEquals(errorMessage, song.artist, actualArtist)
                      assertEquals(errorMessage, song.title, actualTitle)
                      assertEquals(errorMessage, song.duration.timeString(), actualDuration)
                  }
      
                  mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun()
      
                  //check currentPlaylist changes to "All Songs"
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      val errorMessage =
                              "After deleting in ADD_PLAYLIST state a playlist that is the currentPlaylist" +
                                      "the currentPlaylist should change to \"All Songs\""
      
                      assertSongItem(errorMessage, itemViewSupplier(), song)
                  }
              }
          }
      
          @Test
          fun checkSearchInPlayMusicStateChangeCurrentPlaylistToAllSongs() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  val playlistName = "My Playlist"
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                          testEmptyName = true
                  )
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes[0]])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  mainButtonSearch.clickAndRun()
      
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      assertSongItem("Wrong list item after search button clicked", itemViewSupplier(), song)
                  }
              }
          }
      
          @Test
          fun checkSearchInAddPlaylistStateDisplaysAllSongsOnAddPlaylistStateAndKeepsCurrentPlaylistInPlayMusicState() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
      
                  mainButtonSearch.clickAndRun()
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  val playlistName = "My Playlist"
      
                  addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer,
                          testEmptyName = true
                  )
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes[0]])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  val playlist =  testedItemsZeroBasedIndexes.map { songFakeList[it] }
      
                  activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist)
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  mainButtonSearch.clickAndRun()
      
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      val itemView = itemViewSupplier()
                      val actualArtist = itemView
                              .findViewByString<TextView>("songSelectorItemTvArtist")
                              .text.toString().lowercase()
                      val actualTitle = itemView
                              .findViewByString<TextView>("songSelectorItemTvTitle")
                              .text.toString().lowercase()
                      val actualDuration = itemView
                              .findViewByString<TextView>("songSelectorItemTvDuration")
                              .text.toString().lowercase()
                      val errorMessage =
                              "After mainButtonSearch is clicked on ADD_PLAYLIST state " +
                                      "the \"All Songs\" playlist should be displaying"
      
                      assertEquals(errorMessage, song.artist, actualArtist)
                      assertEquals(errorMessage, song.title, actualTitle)
                      assertEquals(errorMessage, song.duration.timeString(), actualDuration)
                  }
      
                  mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun()
      
                  mainSongList.assertListItems(playlist) { itemViewSupplier, position, song ->
                      assertSongItem(
                              "After mainButtonSearch is clicked on ADD_PLAYLIST state " +
                                      "the currentPlaylist in PLAY_MUSIC state should not change",
                              itemViewSupplier(), song
                      )
                  }
              }
          }
      }
    learner_created: false
  - name: src/test/java/org/hyperskill/musicplayer/Stage3UnitTest.kt
    visible: false
    text: |-
      package org.hyperskill.musicplayer
      
      import android.Manifest
      import android.os.Handler
      import android.os.SystemClock
      import android.widget.Button
      import android.widget.ImageButton
      import androidx.fragment.app.FragmentContainerView
      import androidx.recyclerview.widget.RecyclerView
      import org.hyperskill.musicplayer.internals.CustomMediaPlayerShadow
      import org.hyperskill.musicplayer.internals.CustomShadowAsyncDifferConfig
      import org.hyperskill.musicplayer.internals.CustomShadowCountDownTimer
      import org.hyperskill.musicplayer.internals.MusicPlayerUnitTests
      import org.hyperskill.musicplayer.internals.SongFake
      import org.junit.Assert.assertEquals
      import org.junit.Assert.assertTrue
      import org.junit.Before
      import org.junit.Test
      import org.junit.runner.RunWith
      import org.robolectric.RobolectricTestRunner
      import org.robolectric.annotation.Config
      import java.time.Duration
      
      // version 1.4
      @Config(shadows = [CustomMediaPlayerShadow::class, CustomShadowCountDownTimer::class, CustomShadowAsyncDifferConfig::class])
      @RunWith(RobolectricTestRunner::class)
      class Stage3UnitTest : MusicPlayerUnitTests<MainActivity>(MainActivity::class.java) {
      
      
          companion object {
      
              const val mainMenuItemIdAddPlaylist = "mainMenuAddPlaylist"
              const val mainMenuItemIdLoadPlaylist = "mainMenuLoadPlaylist"
              const val mainMenuItemIdDeletePlaylist = "mainMenuDeletePlaylist"
      
              val songFakeList = (1..10).map { idNum ->
                  SongFake(
                          id = idNum,
                          artist = "artist$idNum",
                          title = "title$idNum",
                          duration = 215_000
                  )
              }
          }
      
          private val mainButtonSearch by lazy {
              val view = activity.findViewByString<Button>("mainButtonSearch")
      
              val expectedText = "search"
              val actualText = view.text.toString().lowercase()
              assertEquals("wrong text for mainButtonSearch", expectedText, actualText)
      
              view
          }
      
          private val mainSongList by lazy {
              activity.findViewByString<RecyclerView>("mainSongList")
          }
      
          private val mainFragmentContainer by lazy {
              activity.findViewByString<FragmentContainerView>("mainFragmentContainer")
          }
      
          @Before
          fun setUp() {
              CustomShadowCountDownTimer.handler = Handler(activity.mainLooper)
              setupContentProvider(songFakeList)
              shadowActivity.grantPermissions(Manifest.permission.READ_EXTERNAL_STORAGE)
              CustomMediaPlayerShadow.setFakeSong(songFakeList[0])
          }
      
          @Test
          fun checkControllerTriggersMediaPlayerOnDefaultItem(){
      
              testActivity {
                  mainButtonSearch
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch no MediaPlayer should be playing"
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
                  var playTime = 0
      
                  playTime += controllerUi.btnPlayPause.clickAndRun(1_200) // play
                  val messagePlayerShouldStartPlay =
                          "After click on controllerBtnPlayPause right after mainButtonSearch " +
                                  "the default song item should start playing."
                  player.assertControllerPlay(messagePlayerShouldStartPlay, controllerUi, expectedPosition = playTime)
      
                  controllerUi.btnPlayPause.clickAndRun(20_000) // pause
                  val messagePlayingShouldPauseOnClick =
                          "After click on controllerBtnPlayPause on a playing song the mediaPlayer should pause."
                  player.assertControllerPause(messagePlayingShouldPauseOnClick, controllerUi, expectedPosition = playTime)
      
                  playTime += controllerUi.btnPlayPause.clickAndRun(10_100) // play
                  val messagePlayingShouldResumeOnClick =
                          "After click on controllerBtnPlayPause on a paused song the mediaPlayer should resume playing."
                  player.assertControllerPlay(messagePlayingShouldResumeOnClick, controllerUi, expectedPosition = playTime)
                  assertEquals(messagePlayingShouldResumeOnClick, true, player.isPlaying)
      
                  controllerUi.btnStop.clickAndRun(10_000)  // stop
                  val messagePlayingShouldStopOnStopClick =
                          "After click on controllerBtnPlayStop the player should stop."
                  player.assertControllerStop(messagePlayingShouldStopOnStopClick, controllerUi)
              }
          }
      
          @Test
          fun checkImgButtonTriggersMediaPlayerOnListItem() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch no MediaPlayer should be playing"
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
                  var playingTime = 0
      
                  val selectedItemIndex = 1
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedItemIndex])
                  mainSongList.assertSingleListItem(selectedItemIndex) { itemViewSupplier ->
                      // invoking itemViewSupplier might increase clock time
      
                      val timeBefore1 = SystemClock.currentGnssTimeClock().millis()
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause") //play
                      val timeAfter1 = SystemClock.currentGnssTimeClock().millis()
      
                      playingTime += songItemImgBtnPlayPause.clickAndRun(1_200 ) + (timeAfter1 - timeBefore1).toInt()
      
                      // refresh reference to songItemImgBtnPlayPause
                      val timeBefore2 = SystemClock.currentGnssTimeClock().millis()
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val timeAfter2 = SystemClock.currentGnssTimeClock().millis()
      
                      playingTime += (timeAfter2 - timeBefore2).toInt()
      
                      val messagePlayerShouldStartPlay =
                              "After click on songItemImgBtnPlayPause the song item should start playing."
                      player.assertControllerPlay(messagePlayerShouldStartPlay, controllerUi, expectedPosition = playingTime)
      
                      songItemImgBtnPlayPause.clickAndRun(20_000) // pause
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      val messagePlayingShouldPauseOnClick =
                              "After click on songItemImgBtnPlayPause on a playing song the mediaPlayer should pause."
                      player.assertControllerPause(messagePlayingShouldPauseOnClick, controllerUi, expectedPosition = playingTime)
      
                      playingTime += songItemImgBtnPlayPause.clickAndRun(10_100) // play
      
                      val messagePlayingShouldResumeOnClick =
                              "After click on songItemImgBtnPlayPause on a paused song the mediaPlayer should resume playing."
                      player.assertControllerPlay(messagePlayingShouldResumeOnClick, controllerUi, expectedPosition = playingTime)
      
                      controllerUi.btnStop.clickAndRun(10_000) //stop
      
                      val messagePlayingShouldStopOnStopClick =
                              "After click on controllerBtnPlayStop the player should stop."
                      player.assertControllerStop(messagePlayingShouldStopOnStopClick, controllerUi)
                  }
              }
          }
      
          @Test
          fun checkSeekBarChangeWhilePlaying() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing"
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  var playingTime = 0
                  playingTime += controllerUi.btnPlayPause.clickAndRun(1_200)  // play
                  val messagePlayerShouldStartPlay =
                          "After click on controllerBtnPlayPause right after mainButtonSearch the default song item should start playing."
                  player.assertControllerPlay(messagePlayerShouldStartPlay, controllerUi, expectedPosition = playingTime)
      
                  controllerUi.seekBar.setProgressAsUser(100)  // seek with play
                  shadowLooper.idleFor(Duration.ofMillis(100))
                  playingTime = 100_100
      
                  val errorSeekBarChange =
                          "After changing controllerSeekBar progress as user on a playing song " +
                                  "the mediaPlayer should update its currentPosition and remain playing."
                  player.assertControllerPlay(errorSeekBarChange, controllerUi, expectedPosition = playingTime)
      
                  controllerUi.btnPlayPause.clickAndRun()  // pause
                  val messagePauseAfterSeekBarChange =
                          "It should be possible to pause a song after changing controllerSeekBar."
                  player.assertControllerPause(
                          messagePauseAfterSeekBarChange, controllerUi, expectedPosition = playingTime
                  )
              }
          }
      
          @Test
          fun checkSeekBarBeforePlaying() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
                  var playingTime = 0
      
                  controllerUi.seekBar.setProgressAsUser(100) // seek with stop
                  shadowLooper.idleFor(Duration.ofMillis(100))
                  playingTime = 100_000
      
                  val messageSeekBarChangeBeforePlaying =
                          "After changing controllerSeekBar progress as user before playing a song " +
                                  "the mediaPlayer should update its currentPosition and remain paused."
                  player.assertControllerPause(
                          messageSeekBarChangeBeforePlaying, controllerUi, expectedPosition = playingTime
                  )
      
                  playingTime += controllerUi.btnPlayPause.clickAndRun(10_400) // play
      
                  val messagePlayAfterSeekBarChangeBeforePlaying =
                          "It should be possible to play a song after " +
                                  "changing controllerSeekBar progress as user before playing a song."
                  player.assertControllerPlay(
                          messagePlayAfterSeekBarChangeBeforePlaying, controllerUi, expectedPosition = playingTime
                  )
              }
          }
      
          @Test
          fun checkSeekBarAfterStop() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  controllerUi.btnPlayPause.clickAndRun(10_000) // play
                  controllerUi.btnStop.clickAndRun() // stop
      
                  controllerUi.seekBar.setProgressAsUser(100) // seek with stop
                  shadowLooper.idleFor(Duration.ofMillis(1_000))
      
                  val messageSeekBarChangeAfterStop =
                          "After changing controllerSeekBar progress as user with a stopped song " +
                                  "the mediaPlayer should update its currentPosition and remain paused."
                  player.assertControllerPause(
                          messageSeekBarChangeAfterStop, controllerUi, expectedPosition = 100_000
                  )
              }
          }
      
          @Test
          fun checkSeekBarAfterPause() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  controllerUi.btnPlayPause.clickAndRun(10_000) // play
                  controllerUi.btnPlayPause.clickAndRun()  // pause
      
                  controllerUi.seekBar.setProgressAsUser(50) // seek with pause
                  shadowLooper.idleFor(Duration.ofMillis(1_000))
      
                  val messageSeekBarChangeAfterPause =
                          "After changing controllerSeekBar progress as user with a paused song " +
                                  "the mediaPlayer should update its currentPosition and remain paused."
                  player.assertControllerPause(
                          messageSeekBarChangeAfterPause, controllerUi, expectedPosition = 50_000
                  )
              }
          }
      
          @Test
          fun checkMusicEnd() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  controllerUi.seekBar.setProgressAsUser(210) // seek with stop
                  controllerUi.btnPlayPause.clickAndRun(10_000)  // play until end
      
                  val messageSeekBarChangeAfterStop = "When a song ends the player should stop playing."
                  player.assertControllerStop(messageSeekBarChangeAfterStop, controllerUi)
      
                  mainSongList.assertSingleListItem(0) { itemViewSupplier ->
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                              "When the song is finished the image should change to R.drawable.ic_play.",
                              R.drawable.ic_play
                      )
                  }
              }
          }
      
          @Test
          fun checkSeekBarChangeAfterMusicEnd() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  controllerUi.seekBar.setProgressAsUser(210)  // seek with stop
                  controllerUi.btnPlayPause.clickAndRun(10_400)  // play until end
      
                  val messageSeekBarChangeAfterStop = "When a song ends the player should stop playing."
                  player.assertControllerStop(messageSeekBarChangeAfterStop, controllerUi)
      
                  controllerUi.seekBar.setProgressAsUser(200) // seek with stop
                  var playingTime = 200_000
                  playingTime += controllerUi.btnPlayPause.clickAndRun(10_400) // play
                  val messagePlayAfterSeekBarChangeAfterMusicEnd =
                          "It should be possible to change controllerSeekBar progress as user " +
                                  "after a music ends and resume playing the song."
                  player.assertControllerPlay(
                          messagePlayAfterSeekBarChangeAfterMusicEnd, controllerUi, expectedPosition = playingTime
                  )
              }
          }
      
          @Test
          fun checkPlayAfterMusicEnd() {
              testActivity {
                  mainButtonSearch
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  controllerUi.seekBar.setProgressAsUser(210) // seek with stop
                  controllerUi.btnPlayPause.clickAndRun(10_000) // play until end
      
                  val messageSeekBarChangeAfterStop = "When a song ends the player should stop playing."
                  player.assertControllerStop(messageSeekBarChangeAfterStop, controllerUi)
      
                  val playingTime = controllerUi.btnPlayPause.clickAndRun(10_400) // play
                  val messagePlayAfterSeekBarChangeAfterMusicEnd =
                          "It should be possible to play again a song after song end."
                  player.assertControllerPlay(
                          messagePlayAfterSeekBarChangeAfterMusicEnd, controllerUi, expectedPosition = playingTime
                  )
              }
          }
      
          @Test
          fun checkImgButtonPlayAfterMusicEnd() {
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val selectedItemIndex = 2
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedItemIndex])
                  mainSongList.assertSingleListItem(selectedItemIndex){ itemViewSupplier ->
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val controllerUi = mainFragmentContainer.getControllerViews()
      
                      songItemImgBtnPlayPause.clickAndRun() // play
                      controllerUi.seekBar.setProgressAsUser(210)  // seek with play
                      shadowLooper.idleFor(Duration.ofMillis(20_000)) // play until end
      
                      val messageSeekBarChangeAfterStop = "When a song ends the player should stop playing."
                      player.assertControllerStop(messageSeekBarChangeAfterStop, controllerUi)
      
                      songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val playingTime = songItemImgBtnPlayPause.clickAndRun(10_400)  // play
                      val messagePlayAfterSeekBarChangeAfterMusicEnd =
                              "It should be possible to play again a song after song end."
                      player.assertControllerPlay(
                              messagePlayAfterSeekBarChangeAfterMusicEnd, controllerUi, expectedPosition = playingTime
                      )
                  }
              }
          }
      
      
          @Test
          fun checkSongChange() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  mainButtonSearch.clickAndRun()
      
                  if(isPlayerNull().not()) {
                      val messagePlayerPlayingOnSearchClick =
                              "After initial click on mainButtonSearch MediaPlayer should not be playing."
                      assertEquals(messagePlayerPlayingOnSearchClick, false, player.isPlaying)
                  }
      
                  val controllerUi = mainFragmentContainer.getControllerViews()
      
                  CustomMediaPlayerShadow.wasResetOrRecreated = true  // consider first as already created
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, song ->
                      CustomMediaPlayerShadow.setFakeSong(song)
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val playingTime = songItemImgBtnPlayPause.clickAndRun(2_200)  // play
      
                      val messageSongChange =
                              "After click on songItemImgBtnPlayPause on a different songItem the current song should change."
                      assertTrue(messageSongChange, CustomMediaPlayerShadow.wasResetOrRecreated)
      
                      val messagePlaySongItem = "After first click on songItemImgBtnPlayPause that song should play."
                      player.assertControllerPlay(messagePlaySongItem, controllerUi, expectedPosition = playingTime)
      
                      controllerUi.btnPlayPause.clickAndRun()  // pause
      
                      val messagePauseSongItem =
                              "After click on controllerBtnPlayPause with a playing song that song should be paused."
                      player.assertControllerPause(messagePauseSongItem, controllerUi, expectedPosition = playingTime)
      
                      controllerUi.btnStop.clickAndRun()  // stop
      
                      val messageStopSongItem =
                              "After click on controllerBtnStop the song should be stopped"
                      player.assertControllerStop(messageStopSongItem, controllerUi)
      
                      CustomMediaPlayerShadow.wasResetOrRecreated = false
                  }
              }
          }
      
          @Test
          fun checkCancelAddPlaylistKeepsPlayingCurrentSelectedSong() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = testedItemsZeroBasedIndexes[1]
      
                  mainButtonSearch.clickAndRun()
      
                  var playingTime = 0
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
      
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val controllerUi = mainFragmentContainer.getControllerViews()
      
      
                      playingTime += songItemImgBtnPlayPause.clickAndRun(3200) // play
      
                      player.assertControllerPlay(
                              "A song should start playing after click on songItemImgBtnPlayPause",
                              controllerUi,
                              expectedPosition = playingTime
                      )
                  }
      
                  playingTime += activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist, millis = 1_000)
      
                  playingTime += mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun(1_000)
      
                  // give time to controller components to update values
                  shadowLooper.idleFor(Duration.ofMillis(1_100))
                  playingTime += 1_100
                  //
      
                  // check item keeps selected item state after list add
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item, elapsedTime ->
                      // invoking itemViewSupplier might increase clock
      
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      playingTime += elapsedTime + (timeAfter - timeBefore).toInt()
      
                      if (item.id == selectedSongZeroIndex + 1) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          playingTime += adjustPlayerPositionToAvoidSyncIssues()
      
                          player.assertControllerPlay(
                                  "A song should remain playing after list load if present on the loaded list.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnPlayPause.clickAndRun(2_000)  // pause
                          player.assertControllerPause(
                                  "A selected song item should remain responding to controllerBtnPlayPause after list loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime += songItemImgBtnPlayPause.clickAndRun(1_200) // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnStop.clickAndRun() // stop
                          player.assertControllerStop(
                                  "The selected song should remain responding to controllerBtnStop clicks after adding a playlist",
                                  controllerUi
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after loading a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkLoadPlaylistKeepsPlayingCurrentSelectedSong() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = testedItemsZeroBasedIndexes[1]
      
                  mainButtonSearch.clickAndRun()
      
                  var playingTime = 0
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val controllerUi = mainFragmentContainer.getControllerViews()
                      playingTime += songItemImgBtnPlayPause.clickAndRun(3200)   // play
      
                      player.assertControllerPlay(
                              "A song should start playing after click on songItemImgBtnPlayPause",
                              controllerUi,
                              expectedPosition = playingTime
                      )
                  }
      
                  playingTime += activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist, millis = 3_000)
      
                  val playlistName = "My Playlist"
      
                  playingTime += addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // give time to controller components to update values
                  shadowLooper.idleFor(Duration.ofMillis(1_100))
                  playingTime += 1_100
                  //
      
                  // check item keeps selected item state after list add
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item, elapsedTime ->
                      playingTime += elapsedTime
      
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      playingTime += (timeAfter - timeBefore).toInt()
      
                      if (item.id == selectedSongZeroIndex + 1) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          playingTime += adjustPlayerPositionToAvoidSyncIssues()
      
                          player.assertControllerPlay(
                                  "A song should remain playing after list load if present on the loaded list.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnPlayPause.clickAndRun(2_000) // pause
                          player.assertControllerPause(
                                  "A selected song item should remain responding to controllerBtnPlayPause after list loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime += songItemImgBtnPlayPause.clickAndRun(1_200)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnStop.clickAndRun()  // stop
                          player.assertControllerStop(
                                  "The selected song should remain responding to controllerBtnStop clicks after adding a playlist",
                                  controllerUi
                          )
      
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime = songItemImgBtnPlayPause.clickAndRun(1_200)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after loading a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
      
      
                  playingTime += loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  )
      
                  // give time to controller components to update values
                  shadowLooper.idleFor(Duration.ofMillis(1_100))
                  playingTime += 1_100
                  //
      
                  // check item keeps selected item state after list load
                  mainSongList.assertListItems(
                          testedItemsZeroBasedIndexes.map { songFakeList[it] }) { itemViewSupplier, position, item, elapsedTime ->
      
                      playingTime += elapsedTime
      
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      playingTime += (timeAfter - timeBefore).toInt()
      
                      if (item.id == selectedSongZeroIndex + 1) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
                          playingTime += adjustPlayerPositionToAvoidSyncIssues()
      
                          player.assertControllerPlay(
                                  "A song should remain playing after list load if present on the loaded list.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnPlayPause.clickAndRun(2_000)  // pause
                          player.assertControllerPause(
                                  "A selected song item should remain responding to controllerBtnPlayPause after playlist loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime += songItemImgBtnPlayPause.clickAndRun(1_200)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after playlist loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnStop.clickAndRun()  // stop
                          player.assertControllerStop(
                                  "The selected song should remain responding to controllerBtnStop clicks after playlist loaded.",
                                  controllerUi
                          )
      
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime = songItemImgBtnPlayPause.clickAndRun(1_200)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after playlist loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after playlist loaded.",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkLoadPlaylistChangesSongIfCurrentSelectedSongNotInPlaylist() {
      
              testActivity {
                  mainButtonSearch
                  mainSongList
      
                  val testedItemsZeroBasedIndexes = listOf(1, 3, 6)
                  val selectedSongZeroIndex = 8
      
                  mainButtonSearch.clickAndRun()
      
                  var playingTime = 0
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[selectedSongZeroIndex])
                  mainSongList.assertSingleListItem(selectedSongZeroIndex) { itemViewSupplier ->
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      val songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val controllerUi = mainFragmentContainer.getControllerViews()
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      playingTime += songItemImgBtnPlayPause.clickAndRun(3200) + (timeAfter - timeBefore).toInt()  // play
      
                      player.assertControllerPlay(
                              "A song should start playing after click on songItemImgBtnPlayPause.",
                              controllerUi,
                              expectedPosition = playingTime
                      )
                  }
      
                  playingTime += activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist, millis = 3_000)
      
                  val playlistName = "Yes Playlist"
      
                  playingTime += addPlaylist(
                          playlistName = playlistName,
                          selectedItemsIndex = testedItemsZeroBasedIndexes,
                          songListView = mainSongList,
                          fragmentContainer = mainFragmentContainer
                  )
      
                  // give time to controller components to update values
                  shadowLooper.idleFor(Duration.ofMillis(1_100))
                  playingTime += 1_100
                  //
      
                  // check item keeps selected item state after list add
                  mainSongList.assertListItems(songFakeList) { itemViewSupplier, position, item, elapsedTime ->
                      playingTime += elapsedTime
      
                      val timeBefore = SystemClock.currentGnssTimeClock().millis()
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                      val timeAfter = SystemClock.currentGnssTimeClock().millis()
                      playingTime += (timeAfter - timeBefore).toInt()
      
                      if (item.id == selectedSongZeroIndex + 1) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
                          playingTime += adjustPlayerPositionToAvoidSyncIssues()
      
                          player.assertControllerPlay(
                                  "A song should remain playing after adding playlist.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnPlayPause.clickAndRun(2_000)  // pause
                          player.assertControllerPause(
                                  "A selected song item should remain responding to controllerBtnPlayPause after playlist added.",
                                  controllerUi, expectedPosition = playingTime
                          )
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime += songItemImgBtnPlayPause.clickAndRun(1_200)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnStop.clickAndRun()  // stop
                          player.assertControllerStop(
                                  "The selected song should remain responding to controllerBtnStop clicks after adding a playlist.",
                                  controllerUi
                          )
      
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          playingTime = songItemImgBtnPlayPause.clickAndRun(3_100)  // play
                          player.assertControllerPlay(
                                  "The selected song should remain responding to songItemImgBtnPlayPause clicks after adding a playlist.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after adding a playlist.",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
      
                  CustomMediaPlayerShadow.setFakeSong(songFakeList[testedItemsZeroBasedIndexes.first()])
                  loadPlaylist(
                          menuItemIdLoadPlaylist = mainMenuItemIdLoadPlaylist,
                          expectedPlaylistNameList = listOf("All Songs", playlistName),
                          playlistToLoadIndex = 1
                  ) // stop currentTrack because new list does not contain currentTrack
      
                  // give time to controller components to update values
                  shadowLooper.idleFor(Duration.ofMillis(1_100))
                  //
      
      
                  // check item keeps selected item state after list load
                  mainSongList.assertListItems(
                          testedItemsZeroBasedIndexes.map { songFakeList[it] }) { itemViewSupplier, position, item, elapsedTime ->
      
                      var songItemImgBtnPlayPause =
                              itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
      
                      if (position == 0) {
                          val controllerUi = mainFragmentContainer.getControllerViews()
      
                          controllerUi.assertControllerState(
                                  "After loading a playlist without the current selected song" +
                                          " the first item of the loaded list should be selected.",
                                  item, 0
                          )
      
                          playingTime = controllerUi.btnPlayPause.clickAndRun(1_100)  // play
      
                          player.assertControllerPlay(
                                  "If the selected song is not present in the playlist loaded " +
                                          "the first item of the list should be selected and " +
                                          "react to clicks on controllerBtnPlayPause",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          val timeBefore = SystemClock.currentGnssTimeClock().millis()
                          songItemImgBtnPlayPause =
                                  itemViewSupplier().findViewByString<ImageButton>("songItemImgBtnPlayPause")
                          val timeAfter = SystemClock.currentGnssTimeClock().millis()
                          playingTime += (timeAfter - timeBefore).toInt()
      
                          songItemImgBtnPlayPause.clickAndRun(2_000)  // pause
                          player.assertControllerPause(
                                  "The selected song item should respond to " +
                                          "songItemImgBtnPlayPause clicks after playlist loaded.",
                                  controllerUi, expectedPosition = playingTime
                          )
      
                          controllerUi.btnStop.clickAndRun()  // stop
                          player.assertControllerStop(
                                  "The selected song should remain responding to" +
                                          " controllerBtnStop clicks after playlist loaded",
                                  controllerUi
                          )
      
      
                      } else {
                          songItemImgBtnPlayPause.drawable.assertCreatedFromResourceId(
                                  "A unselected song should remain unselected after loading a playlist",
                                  R.drawable.ic_play
                          )
                      }
                  }
                  //
              }
          }
      
          @Test
          fun checkControllerKeepsStateAfterCancelAddPlaylist() {
      
              testActivity {
                  mainButtonSearch.clickAndRun()
                  var playingTime = 0
      
                  mainFragmentContainer.also {
                      val controllerUi = it.getControllerViews()
      
                      controllerUi.seekBar.setProgressAsUser(100)  // seek with stop
                      playingTime = 100_000
                      playingTime += controllerUi.btnPlayPause.clickAndRun(1_100) // play
      
                      val messageWrongStateAfterPlay =
                              "Wrong state of controller view after click on controllerBtnPlayPause after controllerSeekBar change."
                      controllerUi.assertControllerState(
                              messageWrongStateAfterPlay, songFakeList[0], playingTime
                      )
                  }
      
                  playingTime += activity.clickMenuItemAndRun(mainMenuItemIdAddPlaylist, 3_000)
      
                  playingTime += mainFragmentContainer
                          .findViewByString<Button>("addPlaylistBtnCancel")
                          .clickAndRun(1_000)
      
                  mainFragmentContainer.also {
                      val controllerUi = it.getControllerViews()
      
                      playingTime += adjustPlayerPositionToAvoidSyncIssues()
      
                      val messageWrongStateAfterPlay =
                              "Wrong state of controller view after click on addPlaylistBtnCancel"
                      controllerUi.assertControllerState(
                              messageWrongStateAfterPlay, songFakeList[0], playingTime
                      )
                  }
              }
          }
      }
    learner_created: false
feedback_link: https://hyperskill.org/projects/289/stages/1508/implement#comment
status: Unchecked
record: 3
